THERE_BE_DRAGONS_HERE
FileDoesNotExistException: 'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion-cafe.png'
24 November 2024 4:02:47.848 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

File>>openForWrite:
	Receiver: a File
	Arguments and temporary variables: 
		writeMode: 	false
		fileHandle: 	nil
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion...etc...


File>>openForRead
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion...etc...


File>>readStream
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion...etc...


FileHandle>>binaryReadStream
	Receiver: a FileHandle
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		reference: 	File @ C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo...etc...
		writable: 	false
		id: 	nil


FileSystem>>binaryReadStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path * 'picturesParaPharo' / 'evangelion-cafe.png'
	Receiver's instance variables: 
		store: 	a WindowsStore


FileReference>>binaryReadStream
	Receiver: File @ picturesParaPharo\evangelion-cafe.png
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path * 'picturesParaPharo' / 'evangelion-cafe.png'
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>binaryReadStreamDo:
	Receiver: File @ picturesParaPharo\evangelion-cafe.png
	Arguments and temporary variables: 
		aBlock: 	[ :in | self formFromStream: in ]
		stream: 	nil
	Receiver's instance variables: 
		path: 	Path * 'picturesParaPharo' / 'evangelion-cafe.png'
		filesystem: 	a FileSystem


ImageReadWriter class>>formFromFileNamed:
	Receiver: ImageReadWriter
	Arguments and temporary variables: 
		fileName: 	'picturesParaPharo/evangelion-cafe.png'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allTypicalFileExtensions->ImageReadWriter>>#all...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{BMPReadWriter. GIFReadWriter. JPEGReadWriter. PNGReadWriter. Plugi...etc...
		name: 	#ImageReadWriter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Graphics-Files'


Interfaz>>crearVentana
	Receiver: an Interfaz
	Arguments and temporary variables: 
		screenWidth: 	1536
		screenHeight: 	793
	Receiver's instance variables: 
		accionMouse: 	nil
		ventana_1: 	an ImageMorph(445380864)
		ventana_2: 	an ImageMorph(463808512)
		ventana_3: 	a Morph(938029568)
		ventana_4: 	nil
		label_1: 	a TextMorph(787371776)
		label_2: 	a TextMorph(563469056)
		label_3: 	nil
		label_4: 	nil


Timer>>iniciar:
	Receiver: a Timer
	Arguments and temporary variables: 
		uno_sin_tiempo: 	false
		jugadorInicial: 	1
	Receiver's instance variables: 
		timer_1: 	10
		timer_2: 	10
		proceso: 	nil
		turno: 	1
		perdedor: 	nil
		fin: 	false
		j1name: 	'Jugador 12'
		j2name: 	'Jugador 8'
		ventanas: 	an Interfaz


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 12'
		player2: 	'Jugador 8'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	nil


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	12
		listaAdversarios: 	an OrderedCollection(#(3 3) #(4 2) #(4 4))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(419174656)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(407706112)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(407706112)
		secondArg: 	a RubEditingArea(407706112)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(407706112)
		secondArg: 	a RubEditingArea(407706112)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder



--- The full stack ---
File>>openForWrite:
File>>openForRead
File>>readStream
FileHandle>>binaryReadStream
FileSystem>>binaryReadStreamOn:
FileReference>>binaryReadStream
FileReference(AbstractFileReference)>>binaryReadStreamDo:
ImageReadWriter class>>formFromFileNamed:
Interfaz>>crearVentana
Timer>>iniciar:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExistException: 'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion-cafe.png'
24 November 2024 4:02:47.965 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

File>>openForWrite:
	Receiver: a File
	Arguments and temporary variables: 
		writeMode: 	false
		fileHandle: 	nil
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion...etc...


File>>openForRead
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion...etc...


File>>readStream
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo\evangelion...etc...


FileHandle>>binaryReadStream
	Receiver: a FileHandle
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		reference: 	File @ C:\Users\tiago\Documents\Pharo\images\Tiago\picturesParaPharo...etc...
		writable: 	false
		id: 	nil


FileSystem>>binaryReadStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path * 'picturesParaPharo' / 'evangelion-cafe.png'
	Receiver's instance variables: 
		store: 	a WindowsStore


FileReference>>binaryReadStream
	Receiver: File @ picturesParaPharo\evangelion-cafe.png
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path * 'picturesParaPharo' / 'evangelion-cafe.png'
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>binaryReadStreamDo:
	Receiver: File @ picturesParaPharo\evangelion-cafe.png
	Arguments and temporary variables: 
		aBlock: 	[ :in | self formFromStream: in ]
		stream: 	nil
	Receiver's instance variables: 
		path: 	Path * 'picturesParaPharo' / 'evangelion-cafe.png'
		filesystem: 	a FileSystem


ImageReadWriter class>>formFromFileNamed:
	Receiver: ImageReadWriter
	Arguments and temporary variables: 
		fileName: 	'picturesParaPharo/evangelion-cafe.png'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#allTypicalFileExtensions->ImageReadWriter>>#all...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{BMPReadWriter. GIFReadWriter. JPEGReadWriter. PNGReadWriter. Plugi...etc...
		name: 	#ImageReadWriter
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Graphics-Files'


Interfaz>>crearVentana
	Receiver: an Interfaz
	Arguments and temporary variables: 
		screenWidth: 	1536
		screenHeight: 	793
	Receiver's instance variables: 
		accionMouse: 	nil
		ventana_1: 	an ImageMorph(445380864)
		ventana_2: 	an ImageMorph(463808512)
		ventana_3: 	a Morph(938029568)
		ventana_4: 	nil
		label_1: 	a TextMorph(787371776)
		label_2: 	a TextMorph(563469056)
		label_3: 	nil
		label_4: 	nil


Timer>>iniciar:
	Receiver: a Timer
	Arguments and temporary variables: 
		uno_sin_tiempo: 	false
		jugadorInicial: 	1
	Receiver's instance variables: 
		timer_1: 	10
		timer_2: 	10
		proceso: 	nil
		turno: 	1
		perdedor: 	nil
		fin: 	false
		j1name: 	'Jugador 12'
		j2name: 	'Jugador 8'
		ventanas: 	an Interfaz


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 12'
		player2: 	'Jugador 8'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	nil


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	12
		listaAdversarios: 	an OrderedCollection(#(3 3) #(4 2) #(4 4))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(419174656)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(407706112)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(407706112)
		secondArg: 	a RubEditingArea(407706112)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(407706112)
		secondArg: 	a RubEditingArea(407706112)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder



--- The full stack ---
File>>openForWrite:
File>>openForRead
File>>readStream
FileHandle>>binaryReadStream
FileSystem>>binaryReadStreamOn:
FileReference>>binaryReadStream
FileReference(AbstractFileReference)>>binaryReadStreamDo:
ImageReadWriter class>>formFromFileNamed:
Interfaz>>crearVentana
Timer>>iniciar:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExistException: 'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'
24 November 2024 4:04:39.778 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

File>>openForWrite:
	Receiver: a File
	Arguments and temporary variables: 
		writeMode: 	false
		fileHandle: 	nil
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'


File>>openForRead
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'


File>>readStream
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'


FileHandle>>binaryReadStream
	Receiver: a FileHandle
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		reference: 	File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
		writable: 	false
		id: 	nil


FileSystem>>binaryReadStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images'...etc...
	Receiver's instance variables: 
		store: 	a WindowsStore


FileReference>>binaryReadStream
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>readStreamEncoded:
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
		anEncoding: 	'utf8'
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference>>readStream
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
		aBlock: 	[ :stream |
		^ stream contents ]
		stream: 	nil
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>contents
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


Pregunta>>elegirPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoriaCasilla: 	2
		archivo: 	File @ C:\Users\tiago\Documents\Pharo\images\Tiago
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	nil
		respuestas: 	nil
		resultado: 	nil
		correcta: 	nil
		pregunta: 	nil
		nroPregunta: 	nil
		frase: 	nil
		listaPreguntas: 	an OrderedCollection()
		j1: 	'Jugador 6'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	nil
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	nil
		respuestas: 	nil
		resultado: 	nil
		correcta: 	nil
		pregunta: 	nil
		nroPregunta: 	nil
		frase: 	nil
		listaPreguntas: 	an OrderedCollection()
		j1: 	'Jugador 6'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	nil
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 6'
		player2: 	'Jugador 3'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	6
		listaAdversarios: 	an OrderedCollection(#(2 2) #(3 1) #(3 3))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(211340800)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(642155776)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder



--- The full stack ---
File>>openForWrite:
File>>openForRead
File>>readStream
FileHandle>>binaryReadStream
FileSystem>>binaryReadStreamOn:
FileReference>>binaryReadStream
FileReference(AbstractFileReference)>>readStreamEncoded:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
FileReference(AbstractFileReference)>>contents
Pregunta>>elegirPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
FileDoesNotExistException: 'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'
24 November 2024 4:04:39.858 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

File>>openForWrite:
	Receiver: a File
	Arguments and temporary variables: 
		writeMode: 	false
		fileHandle: 	nil
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'


File>>openForRead
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'


File>>readStream
	Receiver: a File
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		name: 	'C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt'


FileHandle>>binaryReadStream
	Receiver: a FileHandle
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		reference: 	File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
		writable: 	false
		id: 	nil


FileSystem>>binaryReadStreamOn:
	Receiver: a FileSystem
	Arguments and temporary variables: 
		aResolvable: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images'...etc...
	Receiver's instance variables: 
		store: 	a WindowsStore


FileReference>>binaryReadStream
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>readStreamEncoded:
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
		anEncoding: 	'utf8'
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference>>readStream
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>readStreamDo:
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
		aBlock: 	[ :stream |
		^ stream contents ]
		stream: 	nil
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


FileReference(AbstractFileReference)>>contents
	Receiver: File @ C:\Users\tiago\Documents\Pharo\images\Tiago\HISTORIA.txt
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		path: 	Path / 'C:' / 'Users' / 'tiago' / 'Documents' / 'Pharo' / 'images' / 'Tia...etc...
		filesystem: 	a FileSystem


Pregunta>>elegirPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoriaCasilla: 	2
		archivo: 	File @ C:\Users\tiago\Documents\Pharo\images\Tiago
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	nil
		respuestas: 	nil
		resultado: 	nil
		correcta: 	nil
		pregunta: 	nil
		nroPregunta: 	nil
		frase: 	nil
		listaPreguntas: 	an OrderedCollection()
		j1: 	'Jugador 6'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	nil
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	nil
		respuestas: 	nil
		resultado: 	nil
		correcta: 	nil
		pregunta: 	nil
		nroPregunta: 	nil
		frase: 	nil
		listaPreguntas: 	an OrderedCollection()
		j1: 	'Jugador 6'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	nil
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 6'
		player2: 	'Jugador 3'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	6
		listaAdversarios: 	an OrderedCollection(#(2 2) #(3 1) #(3 3))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(211340800)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(642155776)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder



--- The full stack ---
File>>openForWrite:
File>>openForRead
File>>readStream
FileHandle>>binaryReadStream
FileSystem>>binaryReadStreamOn:
FileReference>>binaryReadStream
FileReference(AbstractFileReference)>>readStreamEncoded:
FileReference>>readStream
FileReference(AbstractFileReference)>>readStreamDo:
FileReference(AbstractFileReference)>>contents
Pregunta>>elegirPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#delete was sent to nil
24 November 2024 4:07:24.78 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #delete
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	delete
		exception: 	#delete was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #delete
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	delete
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 36'
		player2: 	'Jugador 37'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	36
		listaAdversarios: 	an OrderedCollection(#(3 5) #(5 5) #(4 4) #(4 6))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(980597248)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(184188672)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(184188672)
		secondArg: 	a RubEditingArea(184188672)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(184188672)
		secondArg: 	a RubEditingArea(184188672)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(184188672)
		category: 	a KMCategory
		morph: 	a RubEditingArea(184188672)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #delete
UndefinedObject>>doesNotUnderstand: #delete
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#delete was sent to nil
24 November 2024 4:07:24.888 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #delete
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	delete
		exception: 	#delete was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #delete
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	delete
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 36'
		player2: 	'Jugador 37'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	36
		listaAdversarios: 	an OrderedCollection(#(3 5) #(5 5) #(4 4) #(4 6))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(980597248)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(184188672)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(184188672)
		secondArg: 	a RubEditingArea(184188672)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(184188672)
		secondArg: 	a RubEditingArea(184188672)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(184188672)
		category: 	a KMCategory
		morph: 	a RubEditingArea(184188672)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #delete
UndefinedObject>>doesNotUnderstand: #delete
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 4:45:47.66 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(397211904)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(616.0@237.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a System...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a SystemWindow(157036544) named: Timer>>crearVentana a PopupChoiceDia...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a SystemWindow(157036544) named: Timer>>crearVentana a PopupCho...etc...
		firstIndex: 	1
		lastIndex: 	2


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a System...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(499@32) mouseUp 2094432 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	2094432
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@32)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(499@32) mouseUp 2094432 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2094432
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@32)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(499@32) mouseUp 2094432 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(499@32) mouseUp 2094432 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2094432
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@32)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(499@32) mouseUp 2094432 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(499@32) corner: (515@48)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(499@32) corner: (515@48)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(499@32) mouseUp 2094432 nil]
		targetOffset: 	(70.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a System...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
BlockClosure>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:message:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:message:title:
MorphicUIManager>>chooseFrom:lines:message:title:
MorphicUIManager(UIManager)>>chooseFrom:message:title:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 4:45:47.9 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(397211904)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(616.0@237.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (255.0@421.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (255.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a System...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a SystemWindow(157036544) named: Timer>>crearVentana a PopupChoiceDia...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a SystemWindow(157036544) named: Timer>>crearVentana a PopupCho...etc...
		firstIndex: 	1
		lastIndex: 	2


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a System...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		ar<<error during printing>>

ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(499@32) mouseUp 2094432 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	2094432
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@32)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(499@32) mouseUp 2094432 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2094432
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@32)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(499@32) mouseUp 2094432 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(499@32) mouseUp 2094432 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2094432
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(499@32)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(499@32) mouseUp 2094432 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(499@32) mouseUp 2094432 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(499@32) mouseUp 2094432 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(499@32) corner: (515@48)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(499@32) corner: (515@48)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(499@32) mouseUp 2094432 nil]
		targetOffset: 	(70.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a System...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
BlockClosure>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:message:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:message:title:
MorphicUIManager>>chooseFrom:lines:message:title:
MorphicUIManager(UIManager)>>chooseFrom:message:title:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 4:45:56.465 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		aPoint: 	(616.0@237.0)
		m: 	a PanelMorph(397211904)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newBounds: 	(253.0@394.0) corner: (869.0@631.0)
		oldExtent: 	(2.0@27.0)
		newExtent: 	(616.0@237.0)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newFrame: 	(253.0@394.0) corner: (869.0@631.0)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>restoreBeforeGeneratingThumbnail
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskThumbnailOfSize:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		thumbExtent: 	(320@237.0)
		min: 	nil
		thumb: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>taskbarThumbnail
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PharoLightTheme(UITheme)>>newTaskbarThumbnailIn:for:
	Receiver: a PharoLightTheme
	Arguments and temporary variables: 
		aThemedMorph: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
his...etc...
		aWindow: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia...etc...
		answer: 	nil
		thumb: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		settings: 	a ThemeSettings
		forms: 	a Dictionary(#buttonBottomLeft->Form(12x12x32) #buttonBottomMiddle->Form...etc...
		soundTheme: 	nil
		focusIndicator: 	a RubEditingArea(881509120)->a BorderedMorph(621771776)
		windowActiveDropShadowStyle: 	#diffuse
		useScrollbarThumbShadow: 	nil


PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskbarButtonEntered:event:in:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		aButton: 	a TaskbarItemMorph(522327040)
		evt: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		aMorph: 	a TaskbarItemMorph(522327040)
		buttonBar: 	a TaskbarMorph(65834496)
		thumb: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		sourceMorph: 	a TaskbarItemMorph(522327040)
		arity: 	3
	Receiver's instance variables: 
		event: 	#mouseEnter
		selector: 	#taskbarButtonEntered:event:in:
		recipient: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
histor...etc...
		valueParameter: 	a TaskbarItemMorph(522327040)


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		eventType: 	#mouseEnter
		sourceMorph: 	a TaskbarItemMorph(522327040)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseEnter->a Set(a MorphEventSubscription) #mouse...etc...


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) == tru...etc...
		index: 	4
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil a MorphEventSubscription nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		eventType: 	#mouseEnter
		sourceMorph: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseEnter->a Set(a MorphEventSubscription) #mouse...etc...


MorphicEventHandler>>mouseEnter:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		sourceMorph: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseEnter->a Set(a MorphEventSubscription) #mouse...etc...


TaskbarItemMorph(Morph)>>handleMouseEnter:
	Receiver: a TaskbarItemMorph(522327040)
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(212.0@982.0) corner: (326.0@1007.0)
		owner: 	a TaskbarMorph(65834496)
		submorphs: 	an Array(an AlignmentMorph(883116800))
		fullBounds: 	nil
		color: 	(Color r: 0.0 g: 0.0 b: 0.0 alpha: 0.14901960784313725)
		extension: 	a MorphExtension (213244416) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	#simple
		model: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
		label: 	a PanelMorph(926466560)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#isActive
		actionSelector: 	#taskbarButtonClicked
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	#taskbarButtonMenu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a PanelMorph(926466560)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	true


MouseMoveEvent(MouseEvent)>>sentTo:
	Receiver: [(322@981) (316@982) mouseEnter 2103299 nil]
	Arguments and temporary variables: 
		anObject: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		timeStamp: 	2103299
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseEnter
		buttons: 	0
		position: 	(316@982)
		handler: 	nil
		wasHandled: 	true
		startPoint: 	(322@981)
		trail: 	{(322@981). (316@982)}


MouseMoveEvent>>sentTo:
	Receiver: [(322@981) (316@982) mouseEnter 2103299 nil]
	Arguments and temporary variables: 
		anObject: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		timeStamp: 	2103299
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseEnter
		buttons: 	0
		position: 	(316@982)
		handler: 	nil
		wasHandled: 	true
		startPoint: 	(322@981)
		trail: 	{(322@981). (316@982)}


TaskbarItemMorph(Morph)>>handleEvent:
	Receiver: a TaskbarItemMorph(522327040)
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
	Receiver's instance variables: 
		bounds: 	(212.0@982.0) corner: (326.0@1007.0)
		owner: 	a TaskbarMorph(65834496)
		submorphs: 	an Array(an AlignmentMorph(883116800))
		fullBounds: 	nil
		color: 	(Color r: 0.0 g: 0.0 b: 0.0 alpha: 0.14901960784313725)
		extension: 	a MorphExtension (213244416) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	#simple
		model: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
		label: 	a PanelMorph(926466560)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#isActive
		actionSelector: 	#taskbarButtonClicked
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	#taskbarButtonMenu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a PanelMorph(926466560)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	true


MouseOverHandler>>transform:from:andSendTo:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		originalEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		aMorph: 	a TaskbarItemMorph(522327040)
		transformedEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		evt: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		aLeftMorph: 	a TaskbarItemMorph(522327040)
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		aBlock: 	[]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


True>>ifTrue:ifFalse:
	Receiver: true
	Arguments and temporary variables: 
		trueAlternativeBlock: 	[ self transform: evt from: anEvent andSendTo: aLeftMorph...etc...
		falseAlternativeBlock: 	[]
	Receiver's instance variables: 
true

MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		evt: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		aLeftMorph: 	a TaskbarItemMorph(522327040)
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		aBlock: 	[]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		asMouseEnterEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		anEnteredMorph: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


Array(SequenceableCollection)>>reverseDo:
	Receiver: an Array(a TaskbarItemMorph(522327040))
	Arguments and temporary variables: 
		aBlock: 	[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorp...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a TaskbarItemMorph(522327040))

MouseOverHandler>>handleAsMouseEnter:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		asMouseEnterEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


MouseOverHandler>>processMouseOver:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


HandMorph>>handleEvent:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		evt: 	[(322@981) (316@982) mouseMove 2103299 nil]
	Receiver's instance variables: 
		bounds: 	(316@982) corner: (332@998)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(316@982) corner: (332@998)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(316@982) mouseOver 2103299 nil]
		targetOffset: 	(589@425)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 20 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(226714624))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2019713
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	2103287
		activeHand: 	a HandMorph(226714624)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Collap...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(226714624))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2019713
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	2103287
		activeHand: 	a HandMorph(226714624)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Collap...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Collap...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop


--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>restoreBeforeGeneratingThumbnail
PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskThumbnailOfSize:
PopupChoiceDialogWindowWithMessage(Morph)>>taskbarThumbnail
PharoLightTheme(UITheme)>>newTaskbarThumbnailIn:for:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskbarButtonEntered:event:in:
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseEnter:fromMorph:
TaskbarItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
TaskbarItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter:
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 4:45:56.641 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		aPoint: 	(616.0@237.0)
		m: 	a PanelMorph(397211904)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newBounds: 	(253.0@394.0) corner: (869.0@631.0)
		oldExtent: 	(2.0@27.0)
		newExtent: 	(616.0@237.0)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		newFrame: 	(253.0@394.0) corner: (869.0@631.0)
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>restoreBeforeGeneratingThumbnail
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskThumbnailOfSize:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		thumbExtent: 	(320@237.0)
		min: 	nil
		thumb: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>taskbarThumbnail
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


PharoLightTheme(UITheme)>>newTaskbarThumbnailIn:for:
	Receiver: a PharoLightTheme
	Arguments and temporary variables: 
		aThemedMorph: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
his...etc...
		aWindow: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia...etc...
		answer: 	nil
		thumb: 	nil
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		settings: 	a ThemeSettings
		forms: 	a Dictionary(#buttonBottomLeft->Form(12x12x32) #buttonBottomMiddle->Form...etc...
		soundTheme: 	nil
		focusIndicator: 	a RubEditingArea(881509120)->a BorderedMorph(621771776)
		windowActiveDropShadowStyle: 	#diffuse
		useScrollbarThumbShadow: 	nil


PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskbarButtonEntered:event:in:
	Receiver: a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
	Arguments and temporary variables: 
		aButton: 	a TaskbarItemMorph(522327040)
		evt: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		aMorph: 	a TaskbarItemMorph(522327040)
		buttonBar: 	a TaskbarMorph(65834496)
		thumb: 	nil
	Receiver's instance variables: 
		bounds: 	(253.0@394.0) corner: (869.0@631.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(1013093632))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (16248064) [other:  (paneColor -> (Color r: 0.82306...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
historia'
		stripes: 	an Array(a Morph(354821888) a Morph(1005542912))
		label: 	a LabelMorph(541187584)'DUELO
historia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(191655424))
		collapsedFrame: 	(253.0@394.0) corner: (350.0@421.0)
		fullFrame: 	(253.0@394.0) corner: (869.0@631.0)
		isCollapsed: 	false
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(1013093632)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Julio César' ' B) Augusto' ' C) Adriano' ' D)...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(397211904)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(765512448))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(75153152)
		updatingFilter: 	false
		textMorph: 	a TextMorph(382674176)
		iconMorph: 	an ImageMorph(967512064)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 3
¿Quién fue el emperador romano conocido por la construcción...etc...


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		sourceMorph: 	a TaskbarItemMorph(522327040)
		arity: 	3
	Receiver's instance variables: 
		event: 	#mouseEnter
		selector: 	#taskbarButtonEntered:event:in:
		recipient: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
histor...etc...
		valueParameter: 	a TaskbarItemMorph(522327040)


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		eventType: 	#mouseEnter
		sourceMorph: 	a TaskbarItemMorph(522327040)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseEnter->a Set(a MorphEventSubscription) #mouse...etc...


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) == tru...etc...
		index: 	4
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil a MorphEventSubscription nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		eventType: 	#mouseEnter
		sourceMorph: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseEnter->a Set(a MorphEventSubscription) #mouse...etc...


MorphicEventHandler>>mouseEnter:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		sourceMorph: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseEnter->a Set(a MorphEventSubscription) #mouse...etc...


TaskbarItemMorph(Morph)>>handleMouseEnter:
	Receiver: a TaskbarItemMorph(522327040)
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(212.0@982.0) corner: (326.0@1007.0)
		owner: 	a TaskbarMorph(65834496)
		submorphs: 	an Array(an AlignmentMorph(883116800))
		fullBounds: 	nil
		color: 	(Color r: 0.0 g: 0.0 b: 0.0 alpha: 0.14901960784313725)
		extension: 	a MorphExtension (213244416) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	#simple
		model: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
		label: 	a PanelMorph(926466560)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#isActive
		actionSelector: 	#taskbarButtonClicked
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	#taskbarButtonMenu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a PanelMorph(926466560)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	true


MouseMoveEvent(MouseEvent)>>sentTo:
	Receiver: [(322@981) (316@982) mouseEnter 2103299 nil]
	Arguments and temporary variables: 
		anObject: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		timeStamp: 	2103299
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseEnter
		buttons: 	0
		position: 	(316@982)
		handler: 	nil
		wasHandled: 	true
		startPoint: 	(322@981)
		trail: 	{(322@981). (316@982)}


MouseMoveEvent>>sentTo:
	Receiver: [(322@981) (316@982) mouseEnter 2103299 nil]
	Arguments and temporary variables: 
		anObject: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		timeStamp: 	2103299
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseEnter
		buttons: 	0
		position: 	(316@982)
		handler: 	nil
		wasHandled: 	true
		startPoint: 	(322@981)
		trail: 	{(322@981). (316@982)}


TaskbarItemMorph(Morph)>>handleEvent:
	Receiver: a TaskbarItemMorph(522327040)
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
	Receiver's instance variables: 
		bounds: 	(212.0@982.0) corner: (326.0@1007.0)
		owner: 	a TaskbarMorph(65834496)
		submorphs: 	an Array(an AlignmentMorph(883116800))
		fullBounds: 	nil
		color: 	(Color r: 0.0 g: 0.0 b: 0.0 alpha: 0.14901960784313725)
		extension: 	a MorphExtension (213244416) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	2
		borderColor: 	#simple
		model: 	a PopupChoiceDialogWindowWithMessage(1003400960) named: DUELO
historia
		label: 	a PanelMorph(926466560)
		icon: 	nil
		getIconSelector: 	nil
		getStateSelector: 	#isActive
		actionSelector: 	#taskbarButtonClicked
		font: 	nil
		getLabelSelector: 	nil
		getMenuSelector: 	#taskbarButtonMenu:
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a PanelMorph(926466560)
		iconMorph: 	nil
		iconPosition: 	#left
		lastState: 	true


MouseOverHandler>>transform:from:andSendTo:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		originalEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		aMorph: 	a TaskbarItemMorph(522327040)
		transformedEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		evt: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		aLeftMorph: 	a TaskbarItemMorph(522327040)
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		aBlock: 	[]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


True>>ifTrue:ifFalse:
	Receiver: true
	Arguments and temporary variables: 
		trueAlternativeBlock: 	[ self transform: evt from: anEvent andSendTo: aLeftMorph...etc...
		falseAlternativeBlock: 	[]
	Receiver's instance variables: 
true

MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		evt: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		aLeftMorph: 	a TaskbarItemMorph(522327040)
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		aBlock: 	[]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		asMouseEnterEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
		anEnteredMorph: 	a TaskbarItemMorph(522327040)
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


Array(SequenceableCollection)>>reverseDo:
	Receiver: an Array(a TaskbarItemMorph(522327040))
	Arguments and temporary variables: 
		aBlock: 	[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorp...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a TaskbarItemMorph(522327040))

MouseOverHandler>>handleAsMouseEnter:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		asMouseEnterEvent: 	[(322@981) (316@982) mouseEnter 2103299 nil]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a W<<error during printing>>

MouseOverHandler>>processMouseOver:
	Receiver: a MouseOverHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
	Receiver's instance variables: 
		mouseOverMorphs: 	an Array(a TaskbarMorph(65834496) a WorldMorph(603310592) [wor...etc...
		enteredMorphs: 	an Array(a TaskbarItemMorph(522327040))
		overMorphs: 	a WriteStream
		leftMorphs: 	an IdentitySet()


HandMorph>>handleEvent:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
		evt: 	[(322@981) (316@982) mouseMove 2103299 nil]
	Receiver's instance variables: 
		bounds: 	(316@982) corner: (332@998)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(316@982) corner: (332@998)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(316@982) mouseOver 2103299 nil]
		targetOffset: 	(589@425)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(322@981) (316@982) mouseMove 2103299 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 37 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(226714624))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2019713
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	2103287
		activeHand: 	a HandMorph(226714624)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Collap...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(226714624))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2019713
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	2103287
		activeHand: 	a HandMorph(226714624)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Collap...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Collap...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [
		| extraWorldsToDraw |
		extraWorldsToDraw := Extr...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex cr...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop


--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>restoreBeforeGeneratingThumbnail
PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskThumbnailOfSize:
PopupChoiceDialogWindowWithMessage(Morph)>>taskbarThumbnail
PharoLightTheme(UITheme)>>newTaskbarThumbnailIn:for:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>taskbarButtonEntered:event:in:
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseEnter:fromMorph:
TaskbarItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
TaskbarItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter:
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:47:16.726 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Qué equipo de fútbol ha ganado más títulos de la UEFA C...etc...
		respuestas: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bay...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Qué equipo de fútbol ha ganado más títulos de la UEFA Champions Lea...etc...
		nroPregunta: 	'25'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 4'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 4'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Qué equipo de fútbol ha ganado más títulos de la UEFA C...etc...
		respuestas: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bay...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Qué equipo de fútbol ha ganado más títulos de la UEFA Champions Lea...etc...
		nroPregunta: 	'25'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 4'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Qué equipo de fútbol ha ganado más títulos de la UEFA C...etc...
		respuestas: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bay...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Qué equipo de fútbol ha ganado más títulos de la UEFA Champions Lea...etc...
		nroPregunta: 	'25'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 4'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 4'
		player2: 	'Jugador 5'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(3 1) #(5 1) #(4 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(432767488)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(118329856)
		label_4: 	a TextMorph(204065280)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(701319680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(701319680)
		secondArg: 	a RubEditingArea(701319680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(701319680)
		secondArg: 	a RubEditingArea(701319680)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(701319680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(701319680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:47:16.899 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Qué equipo de fútbol ha ganado más títulos de la UEFA C...etc...
		respuestas: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bay...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Qué equipo de fútbol ha ganado más títulos de la UEFA Champions Lea...etc...
		nroPregunta: 	'25'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 4'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 4'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Qué equipo de fútbol ha ganado más títulos de la UEFA C...etc...
		respuestas: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bay...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Qué equipo de fútbol ha ganado más títulos de la UEFA Champions Lea...etc...
		nroPregunta: 	'25'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 4'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Qué equipo de fútbol ha ganado más títulos de la UEFA C...etc...
		respuestas: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bay...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Qué equipo de fútbol ha ganado más títulos de la UEFA Champions Lea...etc...
		nroPregunta: 	'25'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 4'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 4'
		player2: 	'Jugador 5'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(3 1) #(5 1) #(4 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(432767488)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(118329856)
		label_4: 	a TextMorph(204065280)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(701319680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(701319680)
		secondArg: 	a RubEditingArea(701319680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(701319680)
		secondArg: 	a RubEditingArea(701319680)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(701319680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(701319680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStylTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:50:40.129 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'14 ¿En qué siglo se desarrolló el Renacimiento?A) Siglo XII...etc...
		respuestas: 	an OrderedCollection('A) Siglo XII' 'B) Siglo XIV' 'C) Siglo XV' 'D...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué siglo se desarrolló el Renacimiento'
		nroPregunta: 	'14'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('14')
		j1: 	'Jugador 35'
		j2: 	'Jugador 34'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 35'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'14 ¿En qué siglo se desarrolló el Renacimiento?A) Siglo XII...etc...
		respuestas: 	an OrderedCollection('A) Siglo XII' 'B) Siglo XIV' 'C) Siglo XV' 'D...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué siglo se desarrolló el Renacimiento'
		nroPregunta: 	'14'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('14')
		j1: 	'Jugador 35'
		j2: 	'Jugador 34'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'14 ¿En qué siglo se desarrolló el Renacimiento?A) Siglo XII...etc...
		respuestas: 	an OrderedCollection('A) Siglo XII' 'B) Siglo XIV' 'C) Siglo XV' 'D...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué siglo se desarrolló el Renacimiento'
		nroPregunta: 	'14'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('14')
		j1: 	'Jugador 35'
		j2: 	'Jugador 34'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 35'
		player2: 	'Jugador 34'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	35
		listaAdversarios: 	an OrderedCollection(#(2 5) #(4 5) #(3 4) #(3 6))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(816513536)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(948156416)
		label_4: 	a TextMorph(724908800)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(996515840)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(996515840)
		secondArg: 	a RubEditingArea(996515840)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(996515840)
		secondArg: 	a RubEditingArea(996515840)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(996515840)
		category: 	a KMCategory
		morph: 	a RubEditingArea(996515840)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:50:40.311 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'14 ¿En qué siglo se desarrolló el Renacimiento?A) Siglo XII...etc...
		respuestas: 	an OrderedCollection('A) Siglo XII' 'B) Siglo XIV' 'C) Siglo XV' 'D...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué siglo se desarrolló el Renacimiento'
		nroPregunta: 	'14'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('14')
		j1: 	'Jugador 35'
		j2: 	'Jugador 34'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 35'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'14 ¿En qué siglo se desarrolló el Renacimiento?A) Siglo XII...etc...
		respuestas: 	an OrderedCollection('A) Siglo XII' 'B) Siglo XIV' 'C) Siglo XV' 'D...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué siglo se desarrolló el Renacimiento'
		nroPregunta: 	'14'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('14')
		j1: 	'Jugador 35'
		j2: 	'Jugador 34'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'14 ¿En qué siglo se desarrolló el Renacimiento?A) Siglo XII...etc...
		respuestas: 	an OrderedCollection('A) Siglo XII' 'B) Siglo XIV' 'C) Siglo XV' 'D...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué siglo se desarrolló el Renacimiento'
		nroPregunta: 	'14'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('14')
		j1: 	'Jugador 35'
		j2: 	'Jugador 34'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 35'
		player2: 	'Jugador 34'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	35
		listaAdversarios: 	an OrderedCollection(#(2 5) #(4 5) #(3 4) #(3 6))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(816513536)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(948156416)
		label_4: 	a TextMorph(724908800)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
<<error during printing>>

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(996515840)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(996515840)
		secondArg: 	a RubEditingArea(996515840)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(996515840)
		secondArg: 	a RubEditingArea(996515840)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(996515840)
		category: 	a KMCategory
		morph: 	a RubEditingArea(996515840)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 4:52:40.769 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(7362816)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(488.0@211.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) an Image...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO a SpWin...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO a...etc...
		firstIndex: 	1
		lastIndex: 	2


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) an Image...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(475@29) mouseUp 2507584 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	2507584
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(475@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(475@29) mouseUp 2507584 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2507584
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(475@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(475@29) mouseUp 2507584 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(475@29) mouseUp 2507584 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2507584
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(475@29)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(475@29) mouseUp 2507584 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(475@29.0) corner: (491@45.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(475@29.0) corner: (491@45.0)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@29) mouseUp 2507584 nil]
		targetOffset: 	(46.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) an Image...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
BlockClosure>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:message:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:message:title:
MorphicUIManager>>chooseFrom:lines:message:title:
MorphicUIManager(UIManager)>>chooseFrom:message:title:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 4:52:40.943 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(7362816)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(488.0@211.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(545286400))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1029464576) [other:  (paneColor -> (Color r: 0.823...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO'
		stripes: 	an Array(a Morph(1011538688) a Morph(380463360))
		label: 	a LabelMorph(246090496)'DUELO'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(171916288))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@485.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(545286400)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(#(5 2) #(7 2) #(6 1) #(6 3))
		lines: 	#()
		choicesMorph: 	a PanelMorph(7362816)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(219067392))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(317549568)
		updatingFilter: 	false
		textMorph: 	a TextMorph(562757632)
		iconMorph: 	an ImageMorph(751955200)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Elige un contrincante'


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) an Image...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO a SpWin...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a PopupChoiceDialogWindowWithMessage(1035579392) named: DUELO a...etc...
		firstIndex: 	1
		lastIndex: 	2


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) an Image...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(475@29) mouseUp 2507584 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	2507584
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(475@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(475@29) mouseUp 2507584 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2507584
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(475@29)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(475@29) mouseUp 2507584 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(475@29) mouseUp 2507584 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	2507584
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(475@29)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(475@29) mouseUp 2507584 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	<<error during printing>>

[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(475@29) mouseUp 2507584 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(475@29) mouseUp 2507584 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(475@29.0) corner: (491@45.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(475@29.0) corner: (491@45.0)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(475@29) mouseUp 2507584 nil]
		targetOffset: 	(46.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) an Image...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
BlockClosure>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:message:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:message:title:
MorphicUIManager>>chooseFrom:lines:message:title:
MorphicUIManager(UIManager)>>chooseFrom:message:title:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:54:38.709 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(2 8) #(1 7))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(2 8) #(1 7) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(2 8) #(1 7))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(2 8) #(1 7) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	57
		listaAdversarios: 	an OrderedCollection(#(2 8) #(1 7))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(739462144)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(577159936)
		label_4: 	a TextMorph(656416768)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	4
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on ESCAPE do [ :target :morph :event | self bubbleUpEve...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:54:38.894 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(2 8) #(1 7))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(2 8) #(1 7) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(2 8) #(1 7))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(2 8) #(1 7) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	57
		listaAdversarios: 	an OrderedCollection(#(2 8) #(1 7))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(739462144)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(577159936)
		label_4: 	a TextMorph(656416768)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	4
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on ESCAPE do [ :target :morph :event | self bubbleUpEve...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBloTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:55:30.538 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(1 4) #(3 4) #(2 3) #(2 5) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(1 4) #(3 4) #(2 3) #(2 5) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	26
		listaAdversarios: 	an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(365730560)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(12727040)
		label_4: 	a TextMorph(168220928)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	4
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on ESCAPE do [ :target :morph :event | self bubbleUpEve...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:55:30.679 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(1 4) #(3 4) #(2 3) #(2 5) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(1 4) #(3 4) #(2 3) #(2 5) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	26
		listaAdversarios: 	an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(365730560)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(12727040)
		label_4: 	a TextMorph(168220928)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(62078464)
		secondArg: 	a RubEditingArea(62078464)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )
<<error during printing>>

Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	4
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on ESCAPE do [ :target :morph :event | self bubbleUpEve...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(62078464)
		category: 	a KMCategory
		morph: 	a RubEditingArea(62078464)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:56:04.647 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿Qué jugador ha ganado el mayor número de títulos de Gra...etc...
		respuestas: 	an OrderedCollection(' A) Novak Djokovic' 'B) Roger Federer' 'C) Ra...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué jugador ha ganado el mayor número de títulos de Grand Slam en l...etc...
		nroPregunta: 	'02'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 62'
		j2: 	'Jugador 63'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 62'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿Qué jugador ha ganado el mayor número de títulos de Gra...etc...
		respuestas: 	an OrderedCollection(' A) Novak Djokovic' 'B) Roger Federer' 'C) Ra...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué jugador ha ganado el mayor número de títulos de Grand Slam en l...etc...
		nroPregunta: 	'02'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 62'
		j2: 	'Jugador 63'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿Qué jugador ha ganado el mayor número de títulos de Gra...etc...
		respuestas: 	an OrderedCollection(' A) Novak Djokovic' 'B) Roger Federer' 'C) Ra...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué jugador ha ganado el mayor número de títulos de Grand Slam en l...etc...
		nroPregunta: 	'02'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 62'
		j2: 	'Jugador 63'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 62'
		player2: 	'Jugador 63'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	62
		listaAdversarios: 	an OrderedCollection(#(5 8) #(7 8) #(6 7))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(435501568)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(784332032)
		label_4: 	a TextMorph(853000960)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(913364992)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(913364992)
		secondArg: 	a RubEditingArea(913364992)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(913364992)
		secondArg: 	a RubEditingArea(913364992)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(913364992)
		category: 	a KMCategory
		morph: 	a RubEditingArea(913364992)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 4:56:04.748 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿Qué jugador ha ganado el mayor número de títulos de Gra...etc...
		respuestas: 	an OrderedCollection(' A) Novak Djokovic' 'B) Roger Federer' 'C) Ra...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué jugador ha ganado el mayor número de títulos de Grand Slam en l...etc...
		nroPregunta: 	'02'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 62'
		j2: 	'Jugador 63'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 62'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿Qué jugador ha ganado el mayor número de títulos de Gra...etc...
		respuestas: 	an OrderedCollection(' A) Novak Djokovic' 'B) Roger Federer' 'C) Ra...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué jugador ha ganado el mayor número de títulos de Grand Slam en l...etc...
		nroPregunta: 	'02'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 62'
		j2: 	'Jugador 63'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿Qué jugador ha ganado el mayor número de títulos de Gra...etc...
		respuestas: 	an OrderedCollection(' A) Novak Djokovic' 'B) Roger Federer' 'C) Ra...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué jugador ha ganado el mayor número de títulos de Grand Slam en l...etc...
		nroPregunta: 	'02'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 62'
		j2: 	'Jugador 63'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 62'
		player2: 	'Jugador 63'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	62
		listaAdversarios: 	an OrderedCollection(#(5 8) #(7 8) #(6 7))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(435501568)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(784332032)
		label_4: 	a TextMorph(853000960)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(913364992)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(913364992)
		secondArg: 	a RubEditingArea(913364992)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(913364992)
		secondArg: 	a RubEditingArea(913364992)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(913364992)
		category: 	a KMCategory
		morph: 	a RubEditingArea(913364992)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:01:06.776 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Qué país fue invadido por Alemania al inicio de la Segu...etc...
		respuestas: 	an OrderedCollection(' A) Francia' ' B) Polonia' ' C) Bélgica' ' D)...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué país fue invadido por Alemania al inicio de la Segunda Guerra M...etc...
		nroPregunta: 	'13'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 22'
		j2: 	'Jugador 14'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 22'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Qué país fue invadido por Alemania al inicio de la Segu...etc...
		respuestas: 	an OrderedCollection(' A) Francia' ' B) Polonia' ' C) Bélgica' ' D)...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué país fue invadido por Alemania al inicio de la Segunda Guerra M...etc...
		nroPregunta: 	'13'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 22'
		j2: 	'Jugador 14'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Qué país fue invadido por Alemania al inicio de la Segu...etc...
		respuestas: 	an OrderedCollection(' A) Francia' ' B) Polonia' ' C) Bélgica' ' D)...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué país fue invadido por Alemania al inicio de la Segunda Guerra M...etc...
		nroPregunta: 	'13'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 22'
		j2: 	'Jugador 14'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 22'
		player2: 	'Jugador 14'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	22
		listaAdversarios: 	an OrderedCollection(#(5 3) #(7 3) #(6 2) #(6 4))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(113585152)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(988848384)
		label_4: 	a TextMorph(202871552)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(797504256)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(797504256)
		secondArg: 	a RubEditingArea(797504256)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(797504256)
		secondArg: 	a RubEditingArea(797504256)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(797504256)
		category: 	a KMCategory
		morph: 	a RubEditingArea(797504256)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:01:06.903 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Qué país fue invadido por Alemania al inicio de la Segu...etc...
		respuestas: 	an OrderedCollection(' A) Francia' ' B) Polonia' ' C) Bélgica' ' D)...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué país fue invadido por Alemania al inicio de la Segunda Guerra M...etc...
		nroPregunta: 	'13'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 22'
		j2: 	'Jugador 14'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 22'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Qué país fue invadido por Alemania al inicio de la Segu...etc...
		respuestas: 	an OrderedCollection(' A) Francia' ' B) Polonia' ' C) Bélgica' ' D)...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué país fue invadido por Alemania al inicio de la Segunda Guerra M...etc...
		nroPregunta: 	'13'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 22'
		j2: 	'Jugador 14'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Qué país fue invadido por Alemania al inicio de la Segu...etc...
		respuestas: 	an OrderedCollection(' A) Francia' ' B) Polonia' ' C) Bélgica' ' D)...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué país fue invadido por Alemania al inicio de la Segunda Guerra M...etc...
		nroPregunta: 	'13'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 22'
		j2: 	'Jugador 14'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 22'
		player2: 	'Jugador 14'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	22
		listaAdversarios: 	an OrderedCollection(#(5 3) #(7 3) #(6 2) #(6 4))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(113585152)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(988848384)
		label_4: 	a TextMorph(202871552)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(797504256)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(797504256)
		secondArg: 	a RubEditingArea(797504256)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(797504256)
		secondArg: 	a RubEditingArea(797504256)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(797504256)
		category: 	a KMCategory
		morph: 	a RubEditingArea(797504256)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVaTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:09:45.197 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'45 ¿Cuál es el nombre de la teoría que describe la formació...etc...
		respuestas: 	an OrderedCollection(' A) Teoría de la evolución' 'B) Teoría de la ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Cuál es el nombre de la teoría que describe la formación del univer...etc...
		nroPregunta: 	'45'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('45')
		j1: 	'Jugador 35'
		j2: 	'Jugador 36'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'ciencia'
		rtaNum: 	nil
		nom: 	'Jugador 35'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'45 ¿Cuál es el nombre de la teoría que describe la formació...etc...
		respuestas: 	an OrderedCollection(' A) Teoría de la evolución' 'B) Teoría de la ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Cuál es el nombre de la teoría que describe la formación del univer...etc...
		nroPregunta: 	'45'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('45')
		j1: 	'Jugador 35'
		j2: 	'Jugador 36'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'ciencia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'45 ¿Cuál es el nombre de la teoría que describe la formació...etc...
		respuestas: 	an OrderedCollection(' A) Teoría de la evolución' 'B) Teoría de la ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Cuál es el nombre de la teoría que describe la formación del univer...etc...
		nroPregunta: 	'45'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('45')
		j1: 	'Jugador 35'
		j2: 	'Jugador 36'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 35'
		player2: 	'Jugador 36'
		player2cat: 	'ciencia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'ciencia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	35
		listaAdversarios: 	an OrderedCollection(#(2 5) #(4 5) #(3 4) #(3 6))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(158704384)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(255670272)
		label_4: 	a TextMorph(1033206528)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(305515264)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(305515264)
		secondArg: 	a RubEditingArea(305515264)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(305515264)
		secondArg: 	a RubEditingArea(305515264)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(305515264)
		category: 	a KMCategory
		morph: 	a RubEditingArea(305515264)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:09:45.334 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'45 ¿Cuál es el nombre de la teoría que describe la formació...etc...
		respuestas: 	an OrderedCollection(' A) Teoría de la evolución' 'B) Teoría de la ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Cuál es el nombre de la teoría que describe la formación del univer...etc...
		nroPregunta: 	'45'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('45')
		j1: 	'Jugador 35'
		j2: 	'Jugador 36'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'ciencia'
		rtaNum: 	nil
		nom: 	'Jugador 35'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'45 ¿Cuál es el nombre de la teoría que describe la formació...etc...
		respuestas: 	an OrderedCollection(' A) Teoría de la evolución' 'B) Teoría de la ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Cuál es el nombre de la teoría que describe la formación del univer...etc...
		nroPregunta: 	'45'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('45')
		j1: 	'Jugador 35'
		j2: 	'Jugador 36'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'ciencia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'45 ¿Cuál es el nombre de la teoría que describe la formació...etc...
		respuestas: 	an OrderedCollection(' A) Teoría de la evolución' 'B) Teoría de la ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Cuál es el nombre de la teoría que describe la formación del univer...etc...
		nroPregunta: 	'45'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('45')
		j1: 	'Jugador 35'
		j2: 	'Jugador 36'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 35'
		player2: 	'Jugador 36'
		player2cat: 	'ciencia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'ciencia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	35
		listaAdversarios: 	an OrderedCollection(#(2 5) #(4 5) #(3 4) #(3 6))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(158704384)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(255670272)
		label_4: 	a TextMorph(1033206528)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(305515264)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(305515264)
		secondArg: 	a RubEditingArea(305515264)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(305515264)
		secondArg: 	a RubEditingArea(305515264)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(305515264)
		category: 	a KMCategory
		morph: 	a RubEditingArea(305515264)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variableTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:11:33.287 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Quién pintó "La batalla de San Romano"?A) Paolo Uccello...etc...
		respuestas: 	an OrderedCollection('A) Paolo Uccello' 'B) Sandro Botticelli' 'C) ...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Quién pintó "La batalla de San Romano"'
		nroPregunta: 	'25'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 55'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Quién pintó "La batalla de San Romano"?A) Paolo Uccello...etc...
		respuestas: 	an OrderedCollection('A) Paolo Uccello' 'B) Sandro Botticelli' 'C) ...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Quién pintó "La batalla de San Romano"'
		nroPregunta: 	'25'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Quién pintó "La batalla de San Romano"?A) Paolo Uccello...etc...
		respuestas: 	an OrderedCollection('A) Paolo Uccello' 'B) Sandro Botticelli' 'C) ...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Quién pintó "La batalla de San Romano"'
		nroPregunta: 	'25'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 55'
		player2: 	'Jugador 54'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	55
		listaAdversarios: 	an OrderedCollection(#(6 7) #(8 7) #(7 6) #(7 8))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(476399360)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(594852096)
		label_4: 	a TextMorph(16503040)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(93223424)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(93223424)
		secondArg: 	a RubEditingArea(93223424)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(93223424)
		secondArg: 	a RubEditingArea(93223424)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(93223424)
		category: 	a KMCategory
		morph: 	a RubEditingArea(93223424)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:11:33.409 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Quién pintó "La batalla de San Romano"?A) Paolo Uccello...etc...
		respuestas: 	an OrderedCollection('A) Paolo Uccello' 'B) Sandro Botticelli' 'C) ...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Quién pintó "La batalla de San Romano"'
		nroPregunta: 	'25'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 55'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Quién pintó "La batalla de San Romano"?A) Paolo Uccello...etc...
		respuestas: 	an OrderedCollection('A) Paolo Uccello' 'B) Sandro Botticelli' 'C) ...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Quién pintó "La batalla de San Romano"'
		nroPregunta: 	'25'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'25 ¿Quién pintó "La batalla de San Romano"?A) Paolo Uccello...etc...
		respuestas: 	an OrderedCollection('A) Paolo Uccello' 'B) Sandro Botticelli' 'C) ...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Quién pintó "La batalla de San Romano"'
		nroPregunta: 	'25'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 55'
		player2: 	'Jugador 54'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	55
		listaAdversarios: 	an OrderedCollection(#(6 7) #(8 7) #(7 6) #(7 8))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(476399360)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(594852096)
		label_4: 	a TextMorph(16503040)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(93223424)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(93223424)
		secondArg: 	a RubEditingArea(93223424)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(93223424)
		secondArg: 	a RubEditingArea(93223424)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(93223424)
		category: 	a KMCategory
		morph: 	a RubEditingArea(93223424)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:12:43.411 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'24 ¿Qué imperio fue responsable de la expansión del cristia...etc...
		respuestas: 	an OrderedCollection(' A) Imperio Bizantino' ' B) Imperio Romano' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué imperio fue responsable de la expansión del cristianismo en Eur...etc...
		nroPregunta: 	'24'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('24')
		j1: 	'Jugador 52'
		j2: 	'Jugador 44'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 52'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'24 ¿Qué imperio fue responsable de la expansión del cristia...etc...
		respuestas: 	an OrderedCollection(' A) Imperio Bizantino' ' B) Imperio Romano' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué imperio fue responsable de la expansión del cristianismo en Eur...etc...
		nroPregunta: 	'24'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('24')
		j1: 	'Jugador 52'
		j2: 	'Jugador 44'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'24 ¿Qué imperio fue responsable de la expansión del cristia...etc...
		respuestas: 	an OrderedCollection(' A) Imperio Bizantino' ' B) Imperio Romano' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué imperio fue responsable de la expansión del cristianismo en Eur...etc...
		nroPregunta: 	'24'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('24')
		j1: 	'Jugador 52'
		j2: 	'Jugador 44'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 52'
		player2: 	'Jugador 44'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	52
		listaAdversarios: 	an OrderedCollection(#(3 7) #(5 7) #(4 6) #(4 8))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(796125952)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(874979072)
		label_4: 	a TextMorph(503703808)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(852847872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(852847872)
		secondArg: 	a RubEditingArea(852847872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(852847872)
		secondArg: 	a RubEditingArea(852847872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(852847872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(852847872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:12:43.511 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'24 ¿Qué imperio fue responsable de la expansión del cristia...etc...
		respuestas: 	an OrderedCollection(' A) Imperio Bizantino' ' B) Imperio Romano' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué imperio fue responsable de la expansión del cristianismo en Eur...etc...
		nroPregunta: 	'24'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('24')
		j1: 	'Jugador 52'
		j2: 	'Jugador 44'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 52'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'24 ¿Qué imperio fue responsable de la expansión del cristia...etc...
		respuestas: 	an OrderedCollection(' A) Imperio Bizantino' ' B) Imperio Romano' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué imperio fue responsable de la expansión del cristianismo en Eur...etc...
		nroPregunta: 	'24'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('24')
		j1: 	'Jugador 52'
		j2: 	'Jugador 44'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'24 ¿Qué imperio fue responsable de la expansión del cristia...etc...
		respuestas: 	an OrderedCollection(' A) Imperio Bizantino' ' B) Imperio Romano' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué imperio fue responsable de la expansión del cristianismo en Eur...etc...
		nroPregunta: 	'24'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('24')
		j1: 	'Jugador 52'
		j2: 	'Jugador 44'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 52'
		player2: 	'Jugador 44'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	52
		listaAdversarios: 	an OrderedCollection(#(3 7) #(5 7) #(4 6) #(4 8))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(796125952)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(874979072)
		label_4: 	a TextMorph(503703808)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(852847872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(852847872)
		secondArg: 	a RubEditingArea(852847872)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(852847872)
		secondArg: 	a RubEditingArea(852847872)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(852847872)
		category: 	a KMCategory
		morph: 	a RubEditingArea(852847872)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:15:51.661 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Qué es un fenómeno físico? A) Un evento que no se puede...etc...
		respuestas: 	an OrderedCollection(' A) Un evento que no se puede medir' 'B) Un e...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué es un fenómeno físico'
		nroPregunta: 	'32'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 30'
		j2: 	'Jugador 22'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'ciencia'
		rtaNum: 	nil
		nom: 	'Jugador 30'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Qué es un fenómeno físico? A) Un evento que no se puede...etc...
		respuestas: 	an OrderedCollection(' A) Un evento que no se puede medir' 'B) Un e...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué es un fenómeno físico'
		nroPregunta: 	'32'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 30'
		j2: 	'Jugador 22'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'ciencia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Qué es un fenómeno físico? A) Un evento que no se puede...etc...
		respuestas: 	an OrderedCollection(' A) Un evento que no se puede medir' 'B) Un e...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué es un fenómeno físico'
		nroPregunta: 	'32'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 30'
		j2: 	'Jugador 22'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 30'
		player2: 	'Jugador 22'
		player2cat: 	'ciencia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'ciencia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	30
		listaAdversarios: 	an OrderedCollection(#(5 4) #(7 4) #(6 3) #(6 5))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(424419840)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(680486400)
		label_4: 	a TextMorph(352460800)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(821703680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(821703680)
		secondArg: 	a RubEditingArea(821703680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(821703680)
		secondArg: 	a RubEditingArea(821703680)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(821703680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(821703680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:15:51.763 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Qué es un fenómeno físico? A) Un evento que no se puede...etc...
		respuestas: 	an OrderedCollection(' A) Un evento que no se puede medir' 'B) Un e...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué es un fenómeno físico'
		nroPregunta: 	'32'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 30'
		j2: 	'Jugador 22'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'ciencia'
		rtaNum: 	nil
		nom: 	'Jugador 30'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Qué es un fenómeno físico? A) Un evento que no se puede...etc...
		respuestas: 	an OrderedCollection(' A) Un evento que no se puede medir' 'B) Un e...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué es un fenómeno físico'
		nroPregunta: 	'32'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 30'
		j2: 	'Jugador 22'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'ciencia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Qué es un fenómeno físico? A) Un evento que no se puede...etc...
		respuestas: 	an OrderedCollection(' A) Un evento que no se puede medir' 'B) Un e...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué es un fenómeno físico'
		nroPregunta: 	'32'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 30'
		j2: 	'Jugador 22'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 30'
		player2: 	'Jugador 22'
		player2cat: 	'ciencia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'ciencia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	30
		listaAdversarios: 	an OrderedCollection(#(5 4) #(7 4) #(6 3) #(6 5))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(424419840)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(680486400)
		label_4: 	a TextMorph(352460800)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(821703680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(821703680)
		secondArg: 	a RubEditingArea(821703680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(821703680)
		secondArg: 	a RubEditingArea(821703680)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(821703680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(821703680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:16:25.128 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(5 1) #(7 1) #(6 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(5 1) #(7 1) #(6 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(5 1) #(7 1) #(6 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(5 1) #(7 1) #(6 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	6
		listaAdversarios: 	an OrderedCollection(#(5 1) #(7 1) #(6 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(192903424)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(505314048)
		label_4: 	a TextMorph(591538688)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(675870976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(675870976)
		secondArg: 	a RubEditingArea(675870976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(675870976)
		secondArg: 	a RubEditingArea(675870976)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(675870976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(675870976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	22
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(675870976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(675870976)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:16:25.24 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(5 1) #(7 1) #(6 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(5 1) #(7 1) #(6 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(5 1) #(7 1) #(6 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(5 1) #(7 1) #(6 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	6
		listaAdversarios: 	an OrderedCollection(#(5 1) #(7 1) #(6 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(192903424)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(505314048)
		label_4: 	a TextMorph(591538688)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(675870976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(675870976)
		secondArg: 	a RubEditingArea(675870976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(675870976)
		secondArg: 	a RubEditingArea(675870976)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(675870976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(675870976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	22
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(675870976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(675870976)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 5:21:31.779 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(843499520)
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(488.0@237.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a PopupC...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografi...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
ge...etc...
		firstIndex: 	1
		lastIndex: 	2


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a PopupC...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(465@23) mouseUp 4238606 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	4238606
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(465@23)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(465@23) mouseUp 4238606 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	4238606
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(465@23)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(465@23) mouseUp 4238606 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(465@23) mouseUp 4238606 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	4238606
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(465@23)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(465@23) mouseUp 4238606 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(465@23.0) corner: (481@39.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(465@23.0) corner: (481@39.0)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(465@23) mouseUp 4238606 nil]
		targetOffset: 	(36.0@1.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a PopupC...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
BlockClosure>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:message:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:message:title:
MorphicUIManager>>chooseFrom:lines:message:title:
MorphicUIManager(UIManager)>>chooseFrom:message:title:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 5:21:31.908 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(843499520)
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(488.0@237.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(68.0@392.0) corner: (70.0@419.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(930471424))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (588619264) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
geografia'
		stripes: 	an Array(a Morph(544579072) a Morph(167575296))
		label: 	a LabelMorph(1022324480)'DUELO
geografia'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(1025301248))
		collapsedFrame: 	(68.0@392.0) corner: (70.0@419.0)
		fullFrame: 	(68.0@392.0) corner: (556.0@629.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(930471424)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Estrecho de Magallanes' 'B) Estrecho de Berin...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(843499520)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(480029952))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(17229056)
		updatingFilter: 	false
		textMorph: 	a TextMorph(734613504)
		iconMorph: 	an ImageMorph(769702912)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 38
¿Qué estrecho separa Asia de América?'


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografia
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a PopupC...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
geografi...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a PopupChoiceDialogWindowWithMessage(833317120) named: DUELO
ge...etc...
		firstIndex: 	1
		lastIndex: 	2


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a PopupC...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(465@23) mouseUp 4238606 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	4238606
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(465@23)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(465@23) mouseUp 4238606 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	4238606
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(465@23)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(465@23) mouseUp 4238606 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(465@23) mouseUp 4238606 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	4238606
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(465@23)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(465@23) mouseUp 4238606 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(465@23) mouseUp 4238606 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(465@23) mouseUp 4238606 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(465@23.0) corner: (481@39.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(465@23.0) corner: (481@39.0)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(465@23) mouseUp 4238606 nil]
		targetOffset: 	(36.0@1.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a PopupC...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:40:26.252 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Cuál es el país más grande de América del Sur por super...etc...
		respuestas: 	an OrderedCollection(' A) Argentina' 'B) Brasil' 'C) Chile' 'D) Per...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál es el país más grande de América del Sur por superficie'
		nroPregunta: 	'13'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 55'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Cuál es el país más grande de América del Sur por super...etc...
		respuestas: 	an OrderedCollection(' A) Argentina' 'B) Brasil' 'C) Chile' 'D) Per...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál es el país más grande de América del Sur por superficie'
		nroPregunta: 	'13'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Cuál es el país más grande de América del Sur por super...etc...
		respuestas: 	an OrderedCollection(' A) Argentina' 'B) Brasil' 'C) Chile' 'D) Per...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál es el país más grande de América del Sur por superficie'
		nroPregunta: 	'13'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 55'
		player2: 	'Jugador 54'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	55
		listaAdversarios: 	an OrderedCollection(#(6 7) #(8 7) #(7 6) #(7 8))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	6
	Receiver's instance variables: 
		cantPlayers: 	47
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(283906304)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(382898944)
		label_4: 	a TextMorph(980747264)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(88599296)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(88599296)
		secondArg: 	a RubEditingArea(88599296)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(88599296)
		secondArg: 	a RubEditingArea(88599296)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(88599296)
		category: 	a KMCategory
		morph: 	a RubEditingArea(88599296)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:40:26.359 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Cuál es el país más grande de América del Sur por super...etc...
		respuestas: 	an OrderedCollection(' A) Argentina' 'B) Brasil' 'C) Chile' 'D) Per...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál es el país más grande de América del Sur por superficie'
		nroPregunta: 	'13'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 55'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Cuál es el país más grande de América del Sur por super...etc...
		respuestas: 	an OrderedCollection(' A) Argentina' 'B) Brasil' 'C) Chile' 'D) Per...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál es el país más grande de América del Sur por superficie'
		nroPregunta: 	'13'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'13 ¿Cuál es el país más grande de América del Sur por super...etc...
		respuestas: 	an OrderedCollection(' A) Argentina' 'B) Brasil' 'C) Chile' 'D) Per...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál es el país más grande de América del Sur por superficie'
		nroPregunta: 	'13'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('13')
		j1: 	'Jugador 55'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 55'
		player2: 	'Jugador 54'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	55
		listaAdversarios: 	an OrderedCollection(#(6 7) #(8 7) #(7 6) #(7 8))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	6
	Receiver's instance variables: 
		cantPlayers: 	47
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(283906304)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(382898944)
		label_4: 	a TextMorph(980747264)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(88599296)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(88599296)
		secondArg: 	a RubEditingArea(88599296)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(88599296)
		secondArg: 	a RubEditingArea(88599296)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(88599296)
		category: 	a KMCategory
		morph: 	a RubEditingArea(88599296)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:42:07.226 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'03 ¿Qué famoso muralista mexicano pintó "El hombre controla...etc...
		respuestas: 	an OrderedCollection('A) Diego Rivera' 'B) David Alfaro Siqueiros' ...etc...
		resultado: 	5
		correcta: 	'A'
		pregunta: 	'¿Qué famoso muralista mexicano pintó "El hombre controlador del univ...etc...
		nroPregunta: 	'03'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('22¿En' '21' '03')
		j1: 	'Jugador 5'
		j2: 	'Jugador 7'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 7'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'03 ¿Qué famoso muralista mexicano pintó "El hombre controla...etc...
		respuestas: 	an OrderedCollection('A) Diego Rivera' 'B) David Alfaro Siqueiros' ...etc...
		resultado: 	5
		correcta: 	'A'
		pregunta: 	'¿Qué famoso muralista mexicano pintó "El hombre controlador del univ...etc...
		nroPregunta: 	'03'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('22¿En' '21' '03')
		j1: 	'Jugador 5'
		j2: 	'Jugador 7'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'03 ¿Qué famoso muralista mexicano pintó "El hombre controla...etc...
		respuestas: 	an OrderedCollection('A) Diego Rivera' 'B) David Alfaro Siqueiros' ...etc...
		resultado: 	5
		correcta: 	'A'
		pregunta: 	'¿Qué famoso muralista mexicano pintó "El hombre controlador del univ...etc...
		nroPregunta: 	'03'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('22¿En' '21' '03')
		j1: 	'Jugador 5'
		j2: 	'Jugador 7'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 5'
		player2: 	'Jugador 7'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	1
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(4 1) #(5 2) #(7 1) #(6 2))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(239179008)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(868360192)
		label_4: 	a TextMorph(234908672)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(580096512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(580096512)
		secondArg: 	a RubEditingArea(580096512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(580096512)
		secondArg: 	a RubEditingArea(580096512)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(580096512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(580096512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:42:07.327 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'03 ¿Qué famoso muralista mexicano pintó "El hombre controla...etc...
		respuestas: 	an OrderedCollection('A) Diego Rivera' 'B) David Alfaro Siqueiros' ...etc...
		resultado: 	5
		correcta: 	'A'
		pregunta: 	'¿Qué famoso muralista mexicano pintó "El hombre controlador del univ...etc...
		nroPregunta: 	'03'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('22¿En' '21' '03')
		j1: 	'Jugador 5'
		j2: 	'Jugador 7'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 7'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'03 ¿Qué famoso muralista mexicano pintó "El hombre controla...etc...
		respuestas: 	an OrderedCollection('A) Diego Rivera' 'B) David Alfaro Siqueiros' ...etc...
		resultado: 	5
		correcta: 	'A'
		pregunta: 	'¿Qué famoso muralista mexicano pintó "El hombre controlador del univ...etc...
		nroPregunta: 	'03'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('22¿En' '21' '03')
		j1: 	'Jugador 5'
		j2: 	'Jugador 7'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'03 ¿Qué famoso muralista mexicano pintó "El hombre controla...etc...
		respuestas: 	an OrderedCollection('A) Diego Rivera' 'B) David Alfaro Siqueiros' ...etc...
		resultado: 	5
		correcta: 	'A'
		pregunta: 	'¿Qué famoso muralista mexicano pintó "El hombre controlador del univ...etc...
		nroPregunta: 	'03'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('22¿En' '21' '03')
		j1: 	'Jugador 5'
		j2: 	'Jugador 7'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 5'
		player2: 	'Jugador 7'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	1
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(4 1) #(5 2) #(7 1) #(6 2))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(239179008)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(868360192)
		label_4: 	a TextMorph(234908672)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(580096512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(580096512)
		secondArg: 	a RubEditingArea(580096512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(580096512)
		secondArg: 	a RubEditingArea(580096512)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(580096512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(580096512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:43:35.787 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Quién es conocido como "El Rey del Fútbol"? A) Diego Ma...etc...
		respuestas: 	an OrderedCollection(' A) Diego Maradona' 'B) Lionel Messi' 'C) Pel...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Quién es conocido como "El Rey del Fútbol"'
		nroPregunta: 	'15'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 61'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 61'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Quién es conocido como "El Rey del Fútbol"? A) Diego Ma...etc...
		respuestas: 	an OrderedCollection(' A) Diego Maradona' 'B) Lionel Messi' 'C) Pel...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Quién es conocido como "El Rey del Fútbol"'
		nroPregunta: 	'15'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 61'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Quién es conocido como "El Rey del Fútbol"? A) Diego Ma...etc...
		respuestas: 	an OrderedCollection(' A) Diego Maradona' 'B) Lionel Messi' 'C) Pel...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Quién es conocido como "El Rey del Fútbol"'
		nroPregunta: 	'15'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 61'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 61'
		player2: 	'Jugador 54'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	2
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	61
		listaAdversarios: 	an OrderedCollection(#(4 8) #(5 7) #(7 8) #(6 7))
		respuesta: 	4
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(94889984)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(400265728)
		label_4: 	a TextMorph(313385984)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(772655616)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(772655616)
		secondArg: 	a RubEditingArea(772655616)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(772655616)
		secondArg: 	a RubEditingArea(772655616)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(772655616)
		category: 	a KMCategory
		morph: 	a RubEditingArea(772655616)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 5:43:35.902 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Quién es conocido como "El Rey del Fútbol"? A) Diego Ma...etc...
		respuestas: 	an OrderedCollection(' A) Diego Maradona' 'B) Lionel Messi' 'C) Pel...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Quién es conocido como "El Rey del Fútbol"'
		nroPregunta: 	'15'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 61'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 61'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Quién es conocido como "El Rey del Fútbol"? A) Diego Ma...etc...
		respuestas: 	an OrderedCollection(' A) Diego Maradona' 'B) Lionel Messi' 'C) Pel...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Quién es conocido como "El Rey del Fútbol"'
		nroPregunta: 	'15'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 61'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Quién es conocido como "El Rey del Fútbol"? A) Diego Ma...etc...
		respuestas: 	an OrderedCollection(' A) Diego Maradona' 'B) Lionel Messi' 'C) Pel...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Quién es conocido como "El Rey del Fútbol"'
		nroPregunta: 	'15'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 61'
		j2: 	'Jugador 54'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 61'
		player2: 	'Jugador 54'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	2
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	61
		listaAdversarios: 	an OrderedCollection(#(4 8) #(5 7) #(7 8) #(6 7))
		respuesta: 	4
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(94889984)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(400265728)
		label_4: 	a TextMorph(313385984)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(772655616)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(772655616)
		secondArg: 	a RubEditingArea(772655616)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(772655616)
		secondArg: 	a RubEditingArea(772655616)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(772655616)
		category: 	a KMCategory
		morph: 	a RubEditingArea(772655616)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:21:58.812 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'36 ¿En qué continente se encuentra el país de Bután? A) Áfr...etc...
		respuestas: 	an OrderedCollection(' A) África' 'B) Asia' 'C) Europa' 'D) América...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué continente se encuentra el país de Bután'
		nroPregunta: 	'36'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('36')
		j1: 	'Jugador 10'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 10'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'36 ¿En qué continente se encuentra el país de Bután? A) Áfr...etc...
		respuestas: 	an OrderedCollection(' A) África' 'B) Asia' 'C) Europa' 'D) América...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué continente se encuentra el país de Bután'
		nroPregunta: 	'36'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('36')
		j1: 	'Jugador 10'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'36 ¿En qué continente se encuentra el país de Bután? A) Áfr...etc...
		respuestas: 	an OrderedCollection(' A) África' 'B) Asia' 'C) Europa' 'D) América...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué continente se encuentra el país de Bután'
		nroPregunta: 	'36'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('36')
		j1: 	'Jugador 10'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 10'
		player2: 	'Jugador 2'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	10
		listaAdversarios: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(456015616)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(963093760)
		label_4: 	a TextMorph(61247488)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(398201600)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(398201600)
		secondArg: 	a RubEditingArea(398201600)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(398201600)
		secondArg: 	a RubEditingArea(398201600)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(398201600)
		category: 	a KMCategory
		morph: 	a RubEditingArea(398201600)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:21:58.933 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'36 ¿En qué continente se encuentra el país de Bután? A) Áfr...etc...
		respuestas: 	an OrderedCollection(' A) África' 'B) Asia' 'C) Europa' 'D) América...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué continente se encuentra el país de Bután'
		nroPregunta: 	'36'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('36')
		j1: 	'Jugador 10'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 10'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'36 ¿En qué continente se encuentra el país de Bután? A) Áfr...etc...
		respuestas: 	an OrderedCollection(' A) África' 'B) Asia' 'C) Europa' 'D) América...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué continente se encuentra el país de Bután'
		nroPregunta: 	'36'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('36')
		j1: 	'Jugador 10'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'36 ¿En qué continente se encuentra el país de Bután? A) Áfr...etc...
		respuestas: 	an OrderedCollection(' A) África' 'B) Asia' 'C) Europa' 'D) América...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué continente se encuentra el país de Bután'
		nroPregunta: 	'36'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('36')
		j1: 	'Jugador 10'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 10'
		player2: 	'Jugador 2'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	10
		listaAdversarios: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(456015616)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(963093760)
		label_4: 	a TextMorph(61247488)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(398201600)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(398201600)
		secondArg: 	a RubEditingArea(398201600)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(398201600)
		secondArg: 	a RubEditingArea(398201600)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(398201600)
		category: 	a KMCategory
		morph: 	a RubEditingArea(398201600)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:24:07.667 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué tipo de microorganismo puede causar enfermedades? A...etc...
		respuestas: 	an OrderedCollection(' A) Virus' 'B) Bacterias' 'C) Hongos' 'D) Tod...etc...
		resultado: 	2
		correcta: 	'D'
		pregunta: 	'¿Qué tipo de microorganismo puede causar enfermedades'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('11' '04' '36' '22')
		j1: 	'Jugador 2'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'ciencia'
		rtaNum: 	nil
		nom: 	'Jugador 2'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué tipo de microorganismo puede causar enfermedades? A...etc...
		respuestas: 	an OrderedCollection(' A) Virus' 'B) Bacterias' 'C) Hongos' 'D) Tod...etc...
		resultado: 	2
		correcta: 	'D'
		pregunta: 	'¿Qué tipo de microorganismo puede causar enfermedades'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('11' '04' '36' '22')
		j1: 	'Jugador 2'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 2'
		player2: 	'Jugador 3'
		player2cat: 	'ciencia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'ciencia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	2
		listaAdversarios: 	an OrderedCollection(#(1 1) #(3 1) #(2 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(570134272)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(50343168)
		label_4: 	a TextMorph(177092096)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(235565056)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(235565056)
		secondArg: 	a RubEditingArea(235565056)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(235565056)
		secondArg: 	a RubEditingArea(235565056)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(235565056)
		category: 	a KMCategory
		morph: 	a RubEditingArea(235565056)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:24:07.778 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué tipo de microorganismo puede causar enfermedades? A...etc...
		respuestas: 	an OrderedCollection(' A) Virus' 'B) Bacterias' 'C) Hongos' 'D) Tod...etc...
		resultado: 	2
		correcta: 	'D'
		pregunta: 	'¿Qué tipo de microorganismo puede causar enfermedades'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('11' '04' '36' '22')
		j1: 	'Jugador 2'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'ciencia'
		rtaNum: 	nil
		nom: 	'Jugador 2'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué tipo de microorganismo puede causar enfermedades? A...etc...
		respuestas: 	an OrderedCollection(' A) Virus' 'B) Bacterias' 'C) Hongos' 'D) Tod...etc...
		resultado: 	2
		correcta: 	'D'
		pregunta: 	'¿Qué tipo de microorganismo puede causar enfermedades'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es la unidad básica de la vida? A) Tejido%B) Célula%C) Órgan...etc...
		listaPreguntas: 	an OrderedCollection('11' '04' '36' '22')
		j1: 	'Jugador 2'
		j2: 	'Jugador 3'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 2'
		player2: 	'Jugador 3'
		player2cat: 	'ciencia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'ciencia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	2
		listaAdversarios: 	an OrderedCollection(#(1 1) #(3 1) #(2 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(570134272)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(50343168)
		label_4: 	a TextMorph(177092096)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(235565056)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(235565056)
		secondArg: 	a RubEditingArea(235565056)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(235565056)
		secondArg: 	a RubEditingArea(235565056)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(235565056)
		category: 	a KMCategory
		morph: 	a RubEditingArea(235565056)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMoTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:25:40.932 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'18 ¿Qué selección ganó la Eurocopa 2016? A) España%B) Portu...etc...
		respuestas: 	an OrderedCollection(' A) España' 'B) Portugal' 'C) Francia' 'D) Al...etc...
		resultado: 	5
		correcta: 	'B'
		pregunta: 	'¿Qué selección ganó la Eurocopa 2016'
		nroPregunta: 	'18'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('05' '22' '27' '45' '17' '41' '18')
		j1: 	'Jugador 39'
		j2: 	'Jugador 31'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 39'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'18 ¿Qué selección ganó la Eurocopa 2016? A) España%B) Portu...etc...
		respuestas: 	an OrderedCollection(' A) España' 'B) Portugal' 'C) Francia' 'D) Al...etc...
		resultado: 	5
		correcta: 	'B'
		pregunta: 	'¿Qué selección ganó la Eurocopa 2016'
		nroPregunta: 	'18'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('05' '22' '27' '45' '17' '41' '18')
		j1: 	'Jugador 39'
		j2: 	'Jugador 31'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'18 ¿Qué selección ganó la Eurocopa 2016? A) España%B) Portu...etc...
		respuestas: 	an OrderedCollection(' A) España' 'B) Portugal' 'C) Francia' 'D) Al...etc...
		resultado: 	5
		correcta: 	'B'
		pregunta: 	'¿Qué selección ganó la Eurocopa 2016'
		nroPregunta: 	'18'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('05' '22' '27' '45' '17' '41' '18')
		j1: 	'Jugador 39'
		j2: 	'Jugador 31'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 39'
		player2: 	'Jugador 31'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	39
		listaAdversarios: 	an OrderedCollection(#(6 5) #(8 5) #(7 4) #(7 6))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(883215360)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(796000512)
		label_4: 	a TextMorph(635253504)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(9370624)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(9370624)
		secondArg: 	a RubEditingArea(9370624)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(9370624)
		secondArg: 	a RubEditingArea(9370624)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(9370624)
		category: 	a KMCategory
		morph: 	a RubEditingArea(9370624)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:25:41.043 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'18 ¿Qué selección ganó la Eurocopa 2016? A) España%B) Portu...etc...
		respuestas: 	an OrderedCollection(' A) España' 'B) Portugal' 'C) Francia' 'D) Al...etc...
		resultado: 	5
		correcta: 	'B'
		pregunta: 	'¿Qué selección ganó la Eurocopa 2016'
		nroPregunta: 	'18'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('05' '22' '27' '45' '17' '41' '18')
		j1: 	'Jugador 39'
		j2: 	'Jugador 31'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 39'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'18 ¿Qué selección ganó la Eurocopa 2016? A) España%B) Portu...etc...
		respuestas: 	an OrderedCollection(' A) España' 'B) Portugal' 'C) Francia' 'D) Al...etc...
		resultado: 	5
		correcta: 	'B'
		pregunta: 	'¿Qué selección ganó la Eurocopa 2016'
		nroPregunta: 	'18'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('05' '22' '27' '45' '17' '41' '18')
		j1: 	'Jugador 39'
		j2: 	'Jugador 31'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'18 ¿Qué selección ganó la Eurocopa 2016? A) España%B) Portu...etc...
		respuestas: 	an OrderedCollection(' A) España' 'B) Portugal' 'C) Francia' 'D) Al...etc...
		resultado: 	5
		correcta: 	'B'
		pregunta: 	'¿Qué selección ganó la Eurocopa 2016'
		nroPregunta: 	'18'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('05' '22' '27' '45' '17' '41' '18')
		j1: 	'Jugador 39'
		j2: 	'Jugador 31'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 39'
		player2: 	'Jugador 31'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	39
		listaAdversarios: 	an OrderedCollection(#(6 5) #(8 5) #(7 4) #(7 6))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(883215360)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(796000512)
		label_4: 	a TextMorph(635253504)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(9370624)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(9370624)
		secondArg: 	a RubEditingArea(9370624)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(9370624)
		secondArg: 	a RubEditingArea(9370624)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(9370624)
		category: 	a KMCategory
		morph: 	a RubEditingArea(9370624)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:26:18.625 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'40 ¿Cuál fue el nombre del primer cosmonauta en viajar al e...etc...
		respuestas: 	an OrderedCollection(' A) Neil Armstrong' ' B) Yuri Gagarin' ' C) J...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál fue el nombre del primer cosmonauta en viajar al espacio'
		nroPregunta: 	'40'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('40')
		j1: 	'Jugador 8'
		j2: 	'Jugador 16'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 8'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'40 ¿Cuál fue el nombre del primer cosmonauta en viajar al e...etc...
		respuestas: 	an OrderedCollection(' A) Neil Armstrong' ' B) Yuri Gagarin' ' C) J...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál fue el nombre del primer cosmonauta en viajar al espacio'
		nroPregunta: 	'40'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('40')
		j1: 	'Jugador 8'
		j2: 	'Jugador 16'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'40 ¿Cuál fue el nombre del primer cosmonauta en viajar al e...etc...
		respuestas: 	an OrderedCollection(' A) Neil Armstrong' ' B) Yuri Gagarin' ' C) J...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál fue el nombre del primer cosmonauta en viajar al espacio'
		nroPregunta: 	'40'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('40')
		j1: 	'Jugador 8'
		j2: 	'Jugador 16'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 8'
		player2: 	'Jugador 16'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	8
		listaAdversarios: 	an OrderedCollection(#(7 1) #(8 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(1008590336)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(219635200)
		label_4: 	a TextMorph(960577280)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(676776192)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(676776192)
		secondArg: 	a RubEditingArea(676776192)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(676776192)
		secondArg: 	a RubEditingArea(676776192)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(676776192)
		category: 	a KMCategory
		morph: 	a RubEditingArea(676776192)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:26:18.743 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'40 ¿Cuál fue el nombre del primer cosmonauta en viajar al e...etc...
		respuestas: 	an OrderedCollection(' A) Neil Armstrong' ' B) Yuri Gagarin' ' C) J...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál fue el nombre del primer cosmonauta en viajar al espacio'
		nroPregunta: 	'40'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('40')
		j1: 	'Jugador 8'
		j2: 	'Jugador 16'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 8'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'40 ¿Cuál fue el nombre del primer cosmonauta en viajar al e...etc...
		respuestas: 	an OrderedCollection(' A) Neil Armstrong' ' B) Yuri Gagarin' ' C) J...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál fue el nombre del primer cosmonauta en viajar al espacio'
		nroPregunta: 	'40'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('40')
		j1: 	'Jugador 8'
		j2: 	'Jugador 16'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'40 ¿Cuál fue el nombre del primer cosmonauta en viajar al e...etc...
		respuestas: 	an OrderedCollection(' A) Neil Armstrong' ' B) Yuri Gagarin' ' C) J...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Cuál fue el nombre del primer cosmonauta en viajar al espacio'
		nroPregunta: 	'40'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('40')
		j1: 	'Jugador 8'
		j2: 	'Jugador 16'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 8'
		player2: 	'Jugador 16'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	8
		listaAdversarios: 	an OrderedCollection(#(7 1) #(8 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(1008590336)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(219635200)
		label_4: 	a TextMorph(960577280)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(676776192)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(676776192)
		secondArg: 	a RubEditingArea(676776192)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(676776192)
		secondArg: 	a RubEditingArea(676776192)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(676776192)
		category: 	a KMCategory
		morph: 	a RubEditingArea(676776192)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:30:00.099 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué país sudamericano no tiene salida al mar? A) Paragu...etc...
		respuestas: 	an OrderedCollection(' A) Paraguay' 'B) Uruguay' 'C) Chile' 'D) Ven...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué país sudamericano no tiene salida al mar'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('22')
		j1: 	'Jugador 52'
		j2: 	'Jugador 60'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 52'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué país sudamericano no tiene salida al mar? A) Paragu...etc...
		respuestas: 	an OrderedCollection(' A) Paraguay' 'B) Uruguay' 'C) Chile' 'D) Ven...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué país sudamericano no tiene salida al mar'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('22')
		j1: 	'Jugador 52'
		j2: 	'Jugador 60'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué país sudamericano no tiene salida al mar? A) Paragu...etc...
		respuestas: 	an OrderedCollection(' A) Paraguay' 'B) Uruguay' 'C) Chile' 'D) Ven...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué país sudamericano no tiene salida al mar'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('22')
		j1: 	'Jugador 52'
		j2: 	'Jugador 60'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 52'
		player2: 	'Jugador 60'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	2
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	52
		listaAdversarios: 	an OrderedCollection(#(3 7) #(5 7) #(4 6) #(4 8))
		respuesta: 	4
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(149464320)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(567119872)
		label_4: 	a TextMorph(1055292416)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(910230016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(910230016)
		secondArg: 	a RubEditingArea(910230016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(910230016)
		secondArg: 	a RubEditingArea(910230016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(910230016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(910230016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:30:00.208 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué país sudamericano no tiene salida al mar? A) Paragu...etc...
		respuestas: 	an OrderedCollection(' A) Paraguay' 'B) Uruguay' 'C) Chile' 'D) Ven...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué país sudamericano no tiene salida al mar'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('22')
		j1: 	'Jugador 52'
		j2: 	'Jugador 60'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 52'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué país sudamericano no tiene salida al mar? A) Paragu...etc...
		respuestas: 	an OrderedCollection(' A) Paraguay' 'B) Uruguay' 'C) Chile' 'D) Ven...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué país sudamericano no tiene salida al mar'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('22')
		j1: 	'Jugador 52'
		j2: 	'Jugador 60'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'22 ¿Qué país sudamericano no tiene salida al mar? A) Paragu...etc...
		respuestas: 	an OrderedCollection(' A) Paraguay' 'B) Uruguay' 'C) Chile' 'D) Ven...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué país sudamericano no tiene salida al mar'
		nroPregunta: 	'22'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('22')
		j1: 	'Jugador 52'
		j2: 	'Jugador 60'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 52'
		player2: 	'Jugador 60'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	2
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	52
		listaAdversarios: 	an OrderedCollection(#(3 7) #(5 7) #(4 6) #(4 8))
		respuesta: 	4
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(149464320)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(567119872)
		label_4: 	a TextMorph(1055292416)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(910230016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(910230016)
		secondArg: 	a RubEditingArea(910230016)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(910230016)
		secondArg: 	a RubEditingArea(910230016)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(910230016)
		category: 	a KMCategory
		morph: 	a RubEditingArea(910230016)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:31:27.244 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('16' '19')
		j1: 	'Jugador 19'
		j2: 	'Jugador 27'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 27'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('16' '19')
		j1: 	'Jugador 19'
		j2: 	'Jugador 27'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('16' '19')
		j1: 	'Jugador 19'
		j2: 	'Jugador 27'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 19'
		player2: 	'Jugador 27'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	2
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	19
		listaAdversarios: 	an OrderedCollection(#(2 3) #(3 2) #(3 4) #(5 3) #(4 2) #(4 4...etc...
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	3
	Receiver's instance variables: 
		cantPlayers: 	61
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(138160896)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(675702272)
		label_4: 	a TextMorph(644389120)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(147406080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(147406080)
		secondArg: 	a RubEditingArea(147406080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(147406080)
		secondArg: 	a RubEditingArea(147406080)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(147406080)
		category: 	a KMCategory
		morph: 	a RubEditingArea(147406080)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:31:27.359 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('16' '19')
		j1: 	'Jugador 19'
		j2: 	'Jugador 27'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 27'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('16' '19')
		j1: 	'Jugador 19'
		j2: 	'Jugador 27'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('16' '19')
		j1: 	'Jugador 19'
		j2: 	'Jugador 27'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 19'
		player2: 	'Jugador 27'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	2
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	19
		listaAdversarios: 	an OrderedCollection(#(2 3) #(3 2) #(3 4) #(5 3) #(4 2) #(4 4...etc...
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	3
	Receiver's instance variables: 
		cantPlayers: 	61
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(138160896)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(675702272)
		label_4: 	a TextMorph(644389120)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(147406080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(147406080)
		secondArg: 	a RubEditingArea(147406080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(147406080)
		secondArg: 	a RubEditingArea(147406080)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(147406080)
		category: 	a KMCategory
		morph: 	a RubEditingArea(147406080)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:32:31.397 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'17 ¿Qué mar separa Europa de África? A) Mar Mediterráneo%B)...etc...
		respuestas: 	an OrderedCollection(' A) Mar Mediterráneo' 'B) Mar Rojo' 'C) Mar N...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué mar separa Europa de África'
		nroPregunta: 	'17'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17')
		j1: 	'Jugador 18'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 18'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'17 ¿Qué mar separa Europa de África? A) Mar Mediterráneo%B)...etc...
		respuestas: 	an OrderedCollection(' A) Mar Mediterráneo' 'B) Mar Rojo' 'C) Mar N...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué mar separa Europa de África'
		nroPregunta: 	'17'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17')
		j1: 	'Jugador 18'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'17 ¿Qué mar separa Europa de África? A) Mar Mediterráneo%B)...etc...
		respuestas: 	an OrderedCollection(' A) Mar Mediterráneo' 'B) Mar Rojo' 'C) Mar N...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué mar separa Europa de África'
		nroPregunta: 	'17'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17')
		j1: 	'Jugador 18'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 18'
		player2: 	'Jugador 2'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	18
		listaAdversarios: 	an OrderedCollection(#(1 3) #(3 3) #(2 4) #(1 2) #(3 2) #(2 1...etc...
		respuesta: 	6
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(245349120)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(416475648)
		label_4: 	a TextMorph(1061040640)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(330374144)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(330374144)
		secondArg: 	a RubEditingArea(330374144)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(330374144)
		secondArg: 	a RubEditingArea(330374144)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(330374144)
		category: 	a KMCategory
		morph: 	a RubEditingArea(330374144)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:32:31.495 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'17 ¿Qué mar separa Europa de África? A) Mar Mediterráneo%B)...etc...
		respuestas: 	an OrderedCollection(' A) Mar Mediterráneo' 'B) Mar Rojo' 'C) Mar N...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué mar separa Europa de África'
		nroPregunta: 	'17'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17')
		j1: 	'Jugador 18'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 18'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'17 ¿Qué mar separa Europa de África? A) Mar Mediterráneo%B)...etc...
		respuestas: 	an OrderedCollection(' A) Mar Mediterráneo' 'B) Mar Rojo' 'C) Mar N...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué mar separa Europa de África'
		nroPregunta: 	'17'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17')
		j1: 	'Jugador 18'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'17 ¿Qué mar separa Europa de África? A) Mar Mediterráneo%B)...etc...
		respuestas: 	an OrderedCollection(' A) Mar Mediterráneo' 'B) Mar Rojo' 'C) Mar N...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Qué mar separa Europa de África'
		nroPregunta: 	'17'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17')
		j1: 	'Jugador 18'
		j2: 	'Jugador 2'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 18'
		player2: 	'Jugador 2'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	18
		listaAdversarios: 	an OrderedCollection(#(1 3) #(3 3) #(2 4) #(1 2) #(3 2) #(2 1...etc...
		respuesta: 	6
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(245349120)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(416475648)
		label_4: 	a TextMorph(1061040640)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index:<<error during printing>>

SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(330374144)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(330374144)
		secondArg: 	a RubEditingArea(330374144)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(330374144)
		secondArg: 	a RubEditingArea(330374144)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(330374144)
		category: 	a KMCategory
		morph: 	a RubEditingArea(330374144)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:34:02.886 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'10 ¿Qué país fue conocido como la "Joya de la Corona" del I...etc...
		respuestas: 	an OrderedCollection(' A) Australia' ' B) Canadá' ' C) India' ' D) ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Qué país fue conocido como la "Joya de la Corona" del Imperio Britá...etc...
		nroPregunta: 	'10'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('10')
		j1: 	'Jugador 46'
		j2: 	'Jugador 47'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 46'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'10 ¿Qué país fue conocido como la "Joya de la Corona" del I...etc...
		respuestas: 	an OrderedCollection(' A) Australia' ' B) Canadá' ' C) India' ' D) ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Qué país fue conocido como la "Joya de la Corona" del Imperio Britá...etc...
		nroPregunta: 	'10'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('10')
		j1: 	'Jugador 46'
		j2: 	'Jugador 47'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'10 ¿Qué país fue conocido como la "Joya de la Corona" del I...etc...
		respuestas: 	an OrderedCollection(' A) Australia' ' B) Canadá' ' C) India' ' D) ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Qué país fue conocido como la "Joya de la Corona" del Imperio Britá...etc...
		nroPregunta: 	'10'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('10')
		j1: 	'Jugador 46'
		j2: 	'Jugador 47'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 46'
		player2: 	'Jugador 47'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	46
		listaAdversarios: 	an OrderedCollection(#(5 6) #(7 6) #(6 5) #(6 7))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(772683008)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(653729536)
		label_4: 	a TextMorph(708388352)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new)iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 26) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new)iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new)iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 26) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new)iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new)iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new)iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(259184128)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(259184128)
		secondArg: 	a RubEditingArea(259184128)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(259184128)
		secondArg: 	a RubEditingArea(259184128)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(259184128)
		category: 	a KMCategory
		morph: 	a RubEditingArea(259184128)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:34:03.023 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'10 ¿Qué país fue conocido como la "Joya de la Corona" del I...etc...
		respuestas: 	an OrderedCollection(' A) Australia' ' B) Canadá' ' C) India' ' D) ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Qué país fue conocido como la "Joya de la Corona" del Imperio Britá...etc...
		nroPregunta: 	'10'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('10')
		j1: 	'Jugador 46'
		j2: 	'Jugador 47'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 46'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'10 ¿Qué país fue conocido como la "Joya de la Corona" del I...etc...
		respuestas: 	an OrderedCollection(' A) Australia' ' B) Canadá' ' C) India' ' D) ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Qué país fue conocido como la "Joya de la Corona" del Imperio Britá...etc...
		nroPregunta: 	'10'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('10')
		j1: 	'Jugador 46'
		j2: 	'Jugador 47'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'10 ¿Qué país fue conocido como la "Joya de la Corona" del I...etc...
		respuestas: 	an OrderedCollection(' A) Australia' ' B) Canadá' ' C) India' ' D) ...etc...
		resultado: 	nil
		correcta: 	'C'
		pregunta: 	'¿Qué país fue conocido como la "Joya de la Corona" del Imperio Britá...etc...
		nroPregunta: 	'10'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('10')
		j1: 	'Jugador 46'
		j2: 	'Jugador 47'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 46'
		player2: 	'Jugador 47'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	46
		listaAdversarios: 	an OrderedCollection(#(5 6) #(7 6) #(6 5) #(6 7))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(772683008)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(653729536)
		label_4: 	a TextMorph(708388352)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new)iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 26) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new)iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new)iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 26) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new)iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new)iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new)iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(259184128)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(259184128)
		secondArg: 	a RubEditingArea(259184128)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(259184128)
		secondArg: 	a RubEditingArea(259184128)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(259184128)
		category: 	a KMCategory
		morph: 	a RubEditingArea(259184128)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 6:36:32.783 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(1019031552)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(488.0@237.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a SpWindow(393049600) named: Playground a SystemWindow(385517824) nam...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a SpWindow(393049600) named: Playground a SystemWindow(38551782...etc...
		firstIndex: 	1
		lastIndex: 	3


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(480@22) mouseUp 8739619 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	8739619
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(480@22)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(480@22) mouseUp 8739619 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	8739619
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(480@22)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(480@22) mouseUp 8739619 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(480@22) mouseUp 8739619 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	8739619
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(480@22)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(480@22) mouseUp 8739619 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(480@22.0) corner: (496@38.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(480@22.0) corner: (496@38.0)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@22) mouseUp 8739619 nil]
		targetOffset: 	(51.0@0.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(226714624)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #width
UndefinedObject>>doesNotUnderstand: #width
PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
OrderedCollection>>reverseDo:
WorldMorph(PasteUpMorph)>>collapseAll
windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
BlockClosure>>cull:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenubarMenuMorph(Morph)>>processEvent:using:
MenubarMenuMorph(Morph)>>processEvent:
MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
PopupChoiceDialogWindowWithMessage(SystemWindow)>>openModal
PharoLightTheme(UITheme)>>chooseIn:title:message:labels:values:lines:
MorphicUIManager>>chooseFrom:values:lines:message:title:
MorphicUIManager>>chooseFrom:lines:message:title:
MorphicUIManager(UIManager)>>chooseFrom:message:title:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#width was sent to nil
24 November 2024 6:36:32.962 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	width
		exception: 	#width was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #width
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	width
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

PopupChoiceDialogWindowWithMessage(PopupChoiceDialogWindow)>>extent:
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		aPoint: 	(2@2)
		m: 	a PanelMorph(1019031552)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(Morph)>>bounds:
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		newBounds: 	(-100@ -100) corner: (-98@ -98)
		oldExtent: 	(488.0@237.0)
		newExtent: 	(2@2)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>setBoundsWithFlex:
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		newFrame: 	(-100@ -100) corner: (-98@ -98)
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>minimizeOrRestore
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		mc: 	nil
		windowEvent: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


PopupChoiceDialogWindowWithMessage(SystemWindow)>>collapseOrExpand
	Receiver: a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Arguments and temporary variables: 
		cf: 	nil
	Receiver's instance variables: 
		bounds: 	(630.0@274.0) corner: (632.0@301.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	an Array(an AlignmentMorph(221639168))
		fullBounds: 	nil
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (281529088) [other:  (paneColor -> (Color r: 0.8230...etc...
		borderWidth: 	1
		borderColor: 	Color lightGray
		model: 	nil
		labelString: 	'DUELO
deporte'
		stripes: 	an Array(a Morph(756939008) a Morph(183196672))
		label: 	a LabelMorph(572690432)'DUELO
deporte'
		closeBox: 	nil
		collapseBox: 	nil
		paneMorphs: 	an Array(a PanelMorph(520078080))
		collapsedFrame: 	(630.0@274.0) corner: (632.0@301.0)
		fullFrame: 	(630.0@274.0) corner: (1118.0@511.0)
		isCollapsed: 	true
		menuBox: 	nil
		mustNotClose: 	false
		labelWidgetAllowance: 	0
		updatablePanes: 	#()
		labelArea: 	an AlignmentMorph(221639168)
		expandBox: 	nil
		embeddable: 	nil
		isResizeable: 	false
		cancelled: 	true
		choice: 	nil
		labels: 	an OrderedCollection(' A) Manchester United' 'B) Barcelona' 'C) Bayern ...etc...
		lines: 	#()
		choicesMorph: 	a PanelMorph(1019031552)
		choiceMenus: 	an Array(an EmbeddedMenuMorph(875562240))
		filter: 	''
		filterMorph: 	a RubPluggableTextFieldMorph(188800256)
		updatingFilter: 	false
		textMorph: 	a TextMorph(262846208)
		iconMorph: 	an ImageMorph(284773888)
		textFont: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSiz...etc...
		message: 	'Jugador 55
¿Qué equipo de fútbol ha ganado más títulos de la UEFA Cha...etc...


[:w | w collapseOrExpand.  self displayWorld] in WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		w: 	a PopupChoiceDialogWindowWithMessage(697876736) named: DUELO
deporte
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


OrderedCollection>>reverseDo:
	Receiver: an OrderedCollection(a SpWindow(393049600) named: Playground a SystemWindow(385517824) nam...etc...
	Arguments and temporary variables: 
		aBlock: 	[:w | w collapseOrExpand.  self displayWorld]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(a SpWindow(393049600) named: Playground a SystemWindow(38551782...etc...
		firstIndex: 	1
		lastIndex: 	3


WorldMorph(PasteUpMorph)>>collapseAll
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (13401600) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
		with: [ 
			| tmp4 tmp6 tmp8 tmp10 tmp12 tmp14 tmp16 tmp18 tmp20 |
			tmp4 := arg1 item: #'Collapse all windows'.
			tmp4
				action: [ self currentWorld collapseAll ];
				help:
					'Reduce all open windows to collapsed forms that only show titles'
						translated.
			tmp6 := arg1 item: #'Expand all windows'.
			tmp6
				iconName: #expandBoxIcon;
				action: [ self currentWorld expandAll ];
				help:
					'Expand all collapsed windows back to their expanded forms'
						translated.
			tmp8 := arg1 item: #'Fit all windows'.
			tmp8
				action: [ self currentWorld fitAllVisibleWindows ];
				help: 'Fit all open windows as visible in World' translated.
			tmp10 := arg1 item: #'Close all debuggers'.
			tmp10
				help: 'Close all opened debugger in the image.';
				action: [ OupsDebuggerSystem closeAllDebuggers ].
			tmp12 := arg1 item: #'Send top window to back (\)'.
			tmp12
				action: [ SystemWindow sendTopWindowToBack ];
				help:
					'Make the topmost window become the backmost one, and activate the window just beneath it.'
						translated.
			tmp14 := arg1 item: #'Move windows onscreen'.
			tmp14
				action: [ self currentWorld bringWindowsFullOnscreen ];
				help: 'Make all windows fully visible on the screen' translated.
			tmp16 := arg1 item: #'Delete unchanged windows'.
			tmp16
				action: [ self currentWorld closeUnchangedWindows ];
				help:
					'Deletes all windows that do not have unsaved text edits.'
						translated.
			tmp18 := arg1 item: #'Delete all windows discarding edits'.
			tmp18
				action: [ self currentWorld closeAllWindowsDiscardingChanges ];
				help:
					'Deletes all windows even if they have unsaved text edits.'
						translated.
			tmp20 := arg1 item: #'Toggle full screen mode'.
			tmp20
				action: [ Display toggleFullscreen ];
				help:
					'Turn full screen mode on when it is off, off when it is on.'
						translated ] in WorldState class>>windowsOn:
	Receiver: WorldState
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


BlockClosure>>cull:
	Receiver: windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	tmp2
		order: 90;
	...etc...
	Arguments and temporary variables: 
		anArg: 	a WorldState
	Receiver's instance variables: 
		outerContext: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Wind...etc...
		startpc: 	373
		numArgs: 	0


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
		w: 	a WorldMorph(603310592) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
		w: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(480@22) mouseUp 8739619 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		timeStamp: 	8739619
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(480@22)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(480@22) mouseUp 8739619 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	8739619
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(480@22)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(114503936)'Collapse all windows'
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(429.0@22.0) corner: (645.0@39.0)
		owner: 	a MenubarMenuMorph(112510976)
		submorphs: 	#()
		fullBounds: 	(429.0@22.0) corner: (645.0@39.0)
		color: 	Color black
		extension: 	a MorphExtension (202560512) [balloonText] 
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Collapse all windows'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	windowsOn: arg1

	<worldMenu>
	| tmp2 |
	tmp2 := arg1 item: #Windows.
	...etc...
		selector: 	#cull:
		arguments: 	an Array(a WorldState)
		icon: 	Form(10x1x8)
		keyText: 	nil
		getStateSelector: 	nil
		enablementSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
		localEvt: 	[(480@22) mouseUp 8739619 nil]
		index: 	1
		child: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		morphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a Toggl...etc...
		inside: 	false
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MouseButtonEvent>>sentTo:
	Receiver: [(480@22) mouseUp 8739619 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	8739619
		source: 	a HandMorph(226714624)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(480@22)
		handler: 	nil
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		aMorph: 	a MenubarMenuMorph(112510976)
	Receiver's instance variables: 
		morph: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'


MenubarMenuMorph(Morph)>>processEvent:using:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(Morph)>>processEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


MenubarMenuMorph(MenuMorph)>>handleFocusEvent:
	Receiver: a MenubarMenuMorph(112510976)
	Arguments and temporary variables: 
		evt: 	[(480@22) mouseUp 8739619 nil]
	Receiver's instance variables: 
		bounds: 	(424.0@17.0) corner: (650.0@188.0)
		owner: 	nil
		submorphs: 	an Array(a ToggleMenuItemMorph(114503936)'Collapse all windows' a To...etc...
		fullBounds: 	(424@17) corner: (650@188)
		color: 	(Color r: 0.823069403714565 g: 0.823069403714565 b: 0.823069403714565 al...etc...
		extension: 	a MorphExtension (1043735296) [sticky]  [other:  (basicColor -> (Col...etc...
		borderWidth: 	2
		borderColor: 	(Color r: 0.6735092864125122 g: 0.6735092864125122 b: 0.6735092864...etc...
		defaultTarget: 	nil
		selectedItem: 	a ToggleMenuItemMorph(114503936)'Collapse all windows'
		stayUp: 	false
		popUpOwner: 	a MenubarItemMorph(21828352)'Windows'
		activeSubMenu: 	nil
		titleMorph: 	nil
		selection: 	nil


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(226714624)
	Arguments and temporary variables: 
		anEvent: 	[(480@22) mouseUp 8739619 nil]
		focusHolder: 	a MenubarMenuMorph(112510976)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(480@22) mouseUp 8739619 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(480@22.0) corner: (496@38.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(480@22.0) corner: (496@38.0)
		color: 	Color blue
		extension: 	a MorphExtension (707757312)
		mouseFocus: 	nil
		keyboardFocus: 	a MenubarMorph(261299968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(480@22) mouseUp 8739619 nil]
		targetOffset: 	(51.0@0.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:37:05.916 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'21 ¿Cuál es la técnica utilizada por los artistas para crea...etc...
		respuestas: 	an OrderedCollection('A) Perspectiva lineal' 'B) Claroscuro' 'C) Im...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Cuál es la técnica utilizada por los artistas para crear una ilusió...etc...
		nroPregunta: 	'21'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('21')
		j1: 	'Jugador 3'
		j2: 	'Jugador 11'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 3'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'21 ¿Cuál es la técnica utilizada por los artistas para crea...etc...
		respuestas: 	an OrderedCollection('A) Perspectiva lineal' 'B) Claroscuro' 'C) Im...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Cuál es la técnica utilizada por los artistas para crear una ilusió...etc...
		nroPregunta: 	'21'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('21')
		j1: 	'Jugador 3'
		j2: 	'Jugador 11'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'21 ¿Cuál es la técnica utilizada por los artistas para crea...etc...
		respuestas: 	an OrderedCollection('A) Perspectiva lineal' 'B) Claroscuro' 'C) Im...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Cuál es la técnica utilizada por los artistas para crear una ilusió...etc...
		nroPregunta: 	'21'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('21')
		j1: 	'Jugador 3'
		j2: 	'Jugador 11'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 3'
		player2: 	'Jugador 11'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	3
		listaAdversarios: 	an OrderedCollection(#(2 1) #(4 1) #(3 2))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(140168704)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(28266240)
		label_4: 	a TextMorph(480843008)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(605282560)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(605282560)
		secondArg: 	a RubEditingArea(605282560)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(605282560)
		secondArg: 	a RubEditingArea(605282560)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(605282560)
		category: 	a KMCategory
		morph: 	a RubEditingArea(605282560)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 6:37:06.026 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'21 ¿Cuál es la técnica utilizada por los artistas para crea...etc...
		respuestas: 	an OrderedCollection('A) Perspectiva lineal' 'B) Claroscuro' 'C) Im...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Cuál es la técnica utilizada por los artistas para crear una ilusió...etc...
		nroPregunta: 	'21'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('21')
		j1: 	'Jugador 3'
		j2: 	'Jugador 11'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 3'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'21 ¿Cuál es la técnica utilizada por los artistas para crea...etc...
		respuestas: 	an OrderedCollection('A) Perspectiva lineal' 'B) Claroscuro' 'C) Im...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Cuál es la técnica utilizada por los artistas para crear una ilusió...etc...
		nroPregunta: 	'21'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('21')
		j1: 	'Jugador 3'
		j2: 	'Jugador 11'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'21 ¿Cuál es la técnica utilizada por los artistas para crea...etc...
		respuestas: 	an OrderedCollection('A) Perspectiva lineal' 'B) Claroscuro' 'C) Im...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿Cuál es la técnica utilizada por los artistas para crear una ilusió...etc...
		nroPregunta: 	'21'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('21')
		j1: 	'Jugador 3'
		j2: 	'Jugador 11'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 3'
		player2: 	'Jugador 11'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	3
		listaAdversarios: 	an OrderedCollection(#(2 1) #(4 1) #(3 2))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	2
	Receiver's instance variables: 
		cantPlayers: 	62
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(140168704)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(28266240)
		label_4: 	a TextMorph(480843008)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(605282560)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(605282560)
		secondArg: 	a RubEditingArea(605282560)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(605282560)
		secondArg: 	a RubEditingArea(605282560)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(605282560)
		category: 	a KMCategory
		morph: 	a RubEditingArea(605282560)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:26:44.417 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'26 ¿En qué deporte se utiliza un disco llamado "puck"? A) H...etc...
		respuestas: 	an OrderedCollection(' A) Hockey sobre hielo' 'B) Lacrosse' 'C) Wat...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿En qué deporte se utiliza un disco llamado "puck"'
		nroPregunta: 	'26'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('26')
		j1: 	'Jugador 47'
		j2: 	'Jugador 39'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 47'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'26 ¿En qué deporte se utiliza un disco llamado "puck"? A) H...etc...
		respuestas: 	an OrderedCollection(' A) Hockey sobre hielo' 'B) Lacrosse' 'C) Wat...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿En qué deporte se utiliza un disco llamado "puck"'
		nroPregunta: 	'26'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('26')
		j1: 	'Jugador 47'
		j2: 	'Jugador 39'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'26 ¿En qué deporte se utiliza un disco llamado "puck"? A) H...etc...
		respuestas: 	an OrderedCollection(' A) Hockey sobre hielo' 'B) Lacrosse' 'C) Wat...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿En qué deporte se utiliza un disco llamado "puck"'
		nroPregunta: 	'26'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('26')
		j1: 	'Jugador 47'
		j2: 	'Jugador 39'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 47'
		player2: 	'Jugador 39'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	2
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	47
		listaAdversarios: 	an OrderedCollection(#(6 6) #(8 6) #(7 5) #(6 7) #(8 7) #(7 8...etc...
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanavictoria: 	nil
		screenWidth: 	1920
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(1027317248)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(729091328)
		label_4: 	a TextMorph(354877184)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(544302080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(544302080)
		secondArg: 	a RubEditingArea(544302080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(544302080)
		secondArg: 	a RubEditingArea(544302080)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(544302080)
		category: 	a KMCategory
		morph: 	a RubEditingArea(544302080)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:26:44.545 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'26 ¿En qué deporte se utiliza un disco llamado "puck"? A) H...etc...
		respuestas: 	an OrderedCollection(' A) Hockey sobre hielo' 'B) Lacrosse' 'C) Wat...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿En qué deporte se utiliza un disco llamado "puck"'
		nroPregunta: 	'26'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('26')
		j1: 	'Jugador 47'
		j2: 	'Jugador 39'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'deporte'
		rtaNum: 	nil
		nom: 	'Jugador 47'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'26 ¿En qué deporte se utiliza un disco llamado "puck"? A) H...etc...
		respuestas: 	an OrderedCollection(' A) Hockey sobre hielo' 'B) Lacrosse' 'C) Wat...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿En qué deporte se utiliza un disco llamado "puck"'
		nroPregunta: 	'26'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('26')
		j1: 	'Jugador 47'
		j2: 	'Jugador 39'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'deporte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'26 ¿En qué deporte se utiliza un disco llamado "puck"? A) H...etc...
		respuestas: 	an OrderedCollection(' A) Hockey sobre hielo' 'B) Lacrosse' 'C) Wat...etc...
		resultado: 	nil
		correcta: 	'A'
		pregunta: 	'¿En qué deporte se utiliza un disco llamado "puck"'
		nroPregunta: 	'26'
		frase: 	#('01 ¿En qué año se celebraron los primeros Juegos Olímpicos modernos? ...etc...
		listaPreguntas: 	an OrderedCollection('26')
		j1: 	'Jugador 47'
		j2: 	'Jugador 39'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 47'
		player2: 	'Jugador 39'
		player2cat: 	'deporte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	2
		categoria: 	'deporte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	47
		listaAdversarios: 	an OrderedCollection(#(6 6) #(8 6) #(7 5) #(6 7) #(8 7) #(7 8...etc...
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanavictoria: 	nil
		screenWidth: 	1920
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(1027317248)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(729091328)
		label_4: 	a TextMorph(354877184)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(544302080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(544302080)
		secondArg: 	a RubEditingArea(544302080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(544302080)
		secondArg: 	a RubEditingArea(544302080)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(544302080)
		category: 	a KMCategory
		morph: 	a RubEditingArea(544302080)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:35:35.993 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(5 8) #(7 8) #(6 7))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(5 8) #(7 8) #(6 7) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(5 8) #(7 8) #(6 7))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(5 8) #(7 8) #(6 7) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	62
		listaAdversarios: 	an OrderedCollection(#(5 8) #(7 8) #(6 7))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(309008896)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(134135552)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(134135552)
		secondArg: 	a RubEditingArea(134135552)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(134135552)
		secondArg: 	a RubEditingArea(134135552)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(134135552)
		category: 	a KMCategory
		morph: 	a RubEditingArea(134135552)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(134135552)
		category: 	a KMCategory
		morph: 	a RubEditingArea(134135552)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:35:36.125 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(5 8) #(7 8) #(6 7))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(5 8) #(7 8) #(6 7) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(5 8) #(7 8) #(6 7))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(5 8) #(7 8) #(6 7) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	62
		listaAdversarios: 	an OrderedCollection(#(5 8) #(7 8) #(6 7))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(309008896)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(134135552)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(134135552)
		secondArg: 	a RubEditingArea(134135552)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(134135552)
		secondArg: 	a RubEditingArea(134135552)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(134135552)
		category: 	a KMCategory
		morph: 	a RubEditingArea(134135552)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(134135552)
		category: 	a KMCategory
		morph: 	a RubEditingArea(134135552)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:38:38.618 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿En qué país se encuentra el Monte Everest? A) India%B) ...etc...
		respuestas: 	an OrderedCollection(' A) India' 'B) Nepal' 'C) China' 'D) Bután' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué país se encuentra el Monte Everest'
		nroPregunta: 	'02'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 13'
		j2: 	'Jugador 21'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 13'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿En qué país se encuentra el Monte Everest? A) India%B) ...etc...
		respuestas: 	an OrderedCollection(' A) India' 'B) Nepal' 'C) China' 'D) Bután' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué país se encuentra el Monte Everest'
		nroPregunta: 	'02'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 13'
		j2: 	'Jugador 21'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿En qué país se encuentra el Monte Everest? A) India%B) ...etc...
		respuestas: 	an OrderedCollection(' A) India' 'B) Nepal' 'C) China' 'D) Bután' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué país se encuentra el Monte Everest'
		nroPregunta: 	'02'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 13'
		j2: 	'Jugador 21'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 13'
		player2: 	'Jugador 21'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	13
		listaAdversarios: 	an OrderedCollection(#(4 2) #(6 2) #(5 1) #(5 3))
		respuesta: 	4
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(585361664)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(435346432)
		label_4: 	a TextMorph(554928896)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(896842240)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(896842240)
		secondArg: 	a RubEditingArea(896842240)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(896842240)
		secondArg: 	a RubEditingArea(896842240)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(896842240)
		category: 	a KMCategory
		morph: 	a RubEditingArea(896842240)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:38:38.753 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿En qué país se encuentra el Monte Everest? A) India%B) ...etc...
		respuestas: 	an OrderedCollection(' A) India' 'B) Nepal' 'C) China' 'D) Bután' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué país se encuentra el Monte Everest'
		nroPregunta: 	'02'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 13'
		j2: 	'Jugador 21'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 13'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿En qué país se encuentra el Monte Everest? A) India%B) ...etc...
		respuestas: 	an OrderedCollection(' A) India' 'B) Nepal' 'C) China' 'D) Bután' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué país se encuentra el Monte Everest'
		nroPregunta: 	'02'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 13'
		j2: 	'Jugador 21'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'geografia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'02 ¿En qué país se encuentra el Monte Everest? A) India%B) ...etc...
		respuestas: 	an OrderedCollection(' A) India' 'B) Nepal' 'C) China' 'D) Bután' '...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿En qué país se encuentra el Monte Everest'
		nroPregunta: 	'02'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('02')
		j1: 	'Jugador 13'
		j2: 	'Jugador 21'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 13'
		player2: 	'Jugador 21'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	13
		listaAdversarios: 	an OrderedCollection(#(4 2) #(6 2) #(5 1) #(5 3))
		respuesta: 	4
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(585361664)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(435346432)
		label_4: 	a TextMorph(554928896)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(896842240)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(896842240)
		secondArg: 	a RubEditingArea(896842240)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(896842240)
		secondArg: 	a RubEditingArea(896842240)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(896842240)
		category: 	a KMCategory
		morph: 	a RubEditingArea(896842240)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 7:41:37.697 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 1.0 g: 0.3998044965786901 b: 0.3998044965786901 alph...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 6'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	2
		coordenadasY: 	2
		vecinos: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		categoria: 	'ciencia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		i: 	1
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(207842816)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(334475008)
		label_4: 	a TextMorph(487044352)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(207842816)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(334475008)
		label_4: 	a TextMorph(487044352)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(500933632)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(500933632)
		secondArg: 	a RubEditingArea(500933632)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(500933632)
		secondArg: 	a RubEditingArea(500933632)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(500933632)
		category: 	a KMCategory
		morph: 	a RubEditingArea(500933632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	30
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(500933632)
		category: 	a KMCategory
		morph: 	a RubEditingArea(500933632)



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 7:41:37.787 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 1.0 g: 0.3998044965786901 b: 0.3998044965786901 alph...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 6'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	2
		coordenadasY: 	2
		vecinos: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		categoria: 	'ciencia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		i: 	1
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(207842816)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(334475008)
		label_4: 	a TextMorph(487044352)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(207842816)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(334475008)
		label_4: 	a TextMorph(487044352)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(500933632)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(500933632)
		secondArg: 	a RubEditingArea(500933632)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(500933632)
		secondArg: 	a RubEditingArea(500933632)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(500933632)
		category: 	a KMCategory
		morph: 	a RubEditingArea(500933632)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	30
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(500933632)
		category: 	a KMCategory
		morph: 	a RubEditingArea(500933632)



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 7:42:45.384 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 1.0 g: 0.3998044965786901 b: 0.3998044965786901 alph...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 25'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	1
		coordenadasY: 	4
		vecinos: 	an OrderedCollection(#(2 4) #(1 3) #(1 5))
		categoria: 	'historia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
		i: 	1
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(971335424)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(67812608)
		label_4: 	a TextMorph(488847360)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	26
		listaAdversarios: 	an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(971335424)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(67812608)
		label_4: 	a TextMorph(488847360)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(110820096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(110820096)
		secondArg: 	a RubEditingArea(110820096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(110820096)
		secondArg: 	a RubEditingArea(110820096)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(110820096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(110820096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	12
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(110820096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(110820096)



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 7:42:45.485 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 1.0 g: 0.3998044965786901 b: 0.3998044965786901 alph...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 25'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	1
		coordenadasY: 	4
		vecinos: 	an OrderedCollection(#(2 4) #(1 3) #(1 5))
		categoria: 	'historia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
		i: 	1
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(971335424)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(67812608)
		label_4: 	a TextMorph(488847360)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	26
		listaAdversarios: 	an OrderedCollection(#(1 4) #(3 4) #(2 3) #(2 5))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(971335424)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(67812608)
		label_4: 	a TextMorph(488847360)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(110820096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(110820096)
		secondArg: 	a RubEditingArea(110820096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(110820096)
		secondArg: 	a RubEditingArea(110820096)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(110820096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(110820096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	12
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(110820096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(110820096)



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:43:44.194 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'44 ¿Qué famoso evento de la antigüedad ocurrió en el año 79...etc...
		respuestas: 	an OrderedCollection(' A) La caída de Troya' ' B) El incendio de Ro...etc...
		resultado: 	2
		correcta: 	'C'
		pregunta: 	'¿Qué famoso evento de la antigüedad ocurrió en el año 79 d.C.'
		nroPregunta: 	'44'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('44')
		j1: 	'Jugador 34'
		j2: 	'Jugador 26'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 34'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'44 ¿Qué famoso evento de la antigüedad ocurrió en el año 79...etc...
		respuestas: 	an OrderedCollection(' A) La caída de Troya' ' B) El incendio de Ro...etc...
		resultado: 	2
		correcta: 	'C'
		pregunta: 	'¿Qué famoso evento de la antigüedad ocurrió en el año 79 d.C.'
		nroPregunta: 	'44'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('44')
		j1: 	'Jugador 34'
		j2: 	'Jugador 26'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 34'
		player2: 	'Jugador 26'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	34
		listaAdversarios: 	an OrderedCollection(#(1 5) #(3 5) #(2 4) #(2 6))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(960108032)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(28049664)
		label_4: 	a TextMorph(345982720)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego 
'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(618542080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(618542080)
		secondArg: 	a RubEditingArea(618542080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(618542080)
		secondArg: 	a RubEditingArea(618542080)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(618542080)
		category: 	a KMCategory
		morph: 	a RubEditingArea(618542080)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 7:43:44.282 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'44 ¿Qué famoso evento de la antigüedad ocurrió en el año 79...etc...
		respuestas: 	an OrderedCollection(' A) La caída de Troya' ' B) El incendio de Ro...etc...
		resultado: 	2
		correcta: 	'C'
		pregunta: 	'¿Qué famoso evento de la antigüedad ocurrió en el año 79 d.C.'
		nroPregunta: 	'44'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('44')
		j1: 	'Jugador 34'
		j2: 	'Jugador 26'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 34'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'44 ¿Qué famoso evento de la antigüedad ocurrió en el año 79...etc...
		respuestas: 	an OrderedCollection(' A) La caída de Troya' ' B) El incendio de Ro...etc...
		resultado: 	2
		correcta: 	'C'
		pregunta: 	'¿Qué famoso evento de la antigüedad ocurrió en el año 79 d.C.'
		nroPregunta: 	'44'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('44')
		j1: 	'Jugador 34'
		j2: 	'Jugador 26'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 34'
		player2: 	'Jugador 26'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	34
		listaAdversarios: 	an OrderedCollection(#(1 5) #(3 5) #(2 4) #(2 6))
		respuesta: 	3
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(960108032)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(28049664)
		label_4: 	a TextMorph(345982720)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego 
'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	11


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(618542080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(618542080)
		secondArg: 	a RubEditingArea(618542080)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(618542080)
		secondArg: 	a RubEditingArea(618542080)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(618542080)
		category: 	a KMCategory
		morph: 	a RubEditingArea(618542080)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:05:45.124 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(2 1) #(4 1) #(3 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(2 1) #(4 1) #(3 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(2 1) #(4 1) #(3 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(2 1) #(4 1) #(3 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	3
		listaAdversarios: 	an OrderedCollection(#(2 1) #(4 1) #(3 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(180705536)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(575353344)
		label_4: 	a TextMorph(1041754368)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(143269376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(143269376)
		secondArg: 	a RubEditingArea(143269376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(143269376)
		secondArg: 	a RubEditingArea(143269376)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(143269376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(143269376)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	4
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(143269376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(143269376)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:05:45.26 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(2 1) #(4 1) #(3 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(2 1) #(4 1) #(3 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(2 1) #(4 1) #(3 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(2 1) #(4 1) #(3 2) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	3
		listaAdversarios: 	an OrderedCollection(#(2 1) #(4 1) #(3 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(180705536)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(575353344)
		label_4: 	a TextMorph(1041754368)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(143269376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(143269376)
		secondArg: 	a RubEditingArea(143269376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(143269376)
		secondArg: 	a RubEditingArea(143269376)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(143269376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(143269376)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	4
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(143269376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(143269376)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:25:13.479 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'31 ¿Qué mar rodea a la península de Yucatán? A) Mar Caribe%...etc...
		respuestas: 	an OrderedCollection(' A) Mar Caribe' 'B) Golfo de México' 'C) Mar ...etc...
		resultado: 	2
		correcta: 	'B'
		pregunta: 	'¿Qué mar rodea a la península de Yucatán'
		nroPregunta: 	'31'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17' '31')
		j1: 	'Jugador 1'
		j2: 	'Jugador 2'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 2'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'31 ¿Qué mar rodea a la península de Yucatán? A) Mar Caribe%...etc...
		respuestas: 	an OrderedCollection(' A) Mar Caribe' 'B) Golfo de México' 'C) Mar ...etc...
		resultado: 	2
		correcta: 	'B'
		pregunta: 	'¿Qué mar rodea a la península de Yucatán'
		nroPregunta: 	'31'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17' '31')
		j1: 	'Jugador 1'
		j2: 	'Jugador 2'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 1'
		player2: 	'Jugador 2'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	nil
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	1
		listaAdversarios: 	an OrderedCollection(#(2 1) #(1 2))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(719290112)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(925877760)
		label_4: 	a TextMorph(565032448)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(308475136)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(308475136)
		secondArg: 	a RubEditingArea(308475136)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(308475136)
		secondArg: 	a RubEditingArea(308475136)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(308475136)
		category: 	a KMCategory
		morph: 	a RubEditingArea(308475136)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:25:13.626 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'31 ¿Qué mar rodea a la península de Yucatán? A) Mar Caribe%...etc...
		respuestas: 	an OrderedCollection(' A) Mar Caribe' 'B) Golfo de México' 'C) Mar ...etc...
		resultado: 	2
		correcta: 	'B'
		pregunta: 	'¿Qué mar rodea a la península de Yucatán'
		nroPregunta: 	'31'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17' '31')
		j1: 	'Jugador 1'
		j2: 	'Jugador 2'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'geografia'
		rtaNum: 	nil
		nom: 	'Jugador 2'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'31 ¿Qué mar rodea a la península de Yucatán? A) Mar Caribe%...etc...
		respuestas: 	an OrderedCollection(' A) Mar Caribe' 'B) Golfo de México' 'C) Mar ...etc...
		resultado: 	2
		correcta: 	'B'
		pregunta: 	'¿Qué mar rodea a la península de Yucatán'
		nroPregunta: 	'31'
		frase: 	#('01 ¿Cuál es el río más largo del mundo? A) Amazonas%B) Nilo%C) Yangts...etc...
		listaPreguntas: 	an OrderedCollection('17' '31')
		j1: 	'Jugador 1'
		j2: 	'Jugador 2'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 1'
		player2: 	'Jugador 2'
		player2cat: 	'geografia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	nil
		categoria: 	'geografia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	1
		listaAdversarios: 	an OrderedCollection(#(2 1) #(1 2))
		respuesta: 	1
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(719290112)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(925877760)
		label_4: 	a TextMorph(565032448)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(308475136)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(308475136)
		secondArg: 	a RubEditingArea(308475136)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(308475136)
		secondArg: 	a RubEditingArea(308475136)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(308475136)
		category: 	a KMCategory
		morph: 	a RubEditingArea(308475136)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:37:14.332 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25' '19')
		j1: 	'Jugador 4'
		j2: 	'Jugador 8'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 8'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25' '19')
		j1: 	'Jugador 4'
		j2: 	'Jugador 8'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25' '19')
		j1: 	'Jugador 4'
		j2: 	'Jugador 8'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 4'
		player2: 	'Jugador 8'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	nil
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(3 1) #(4 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(219444480)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(1060967936)
		label_4: 	a TextMorph(58435840)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(846289920)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846289920)
		secondArg: 	a RubEditingArea(846289920)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846289920)
		secondArg: 	a RubEditingArea(846289920)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(846289920)
		category: 	a KMCategory
		morph: 	a RubEditingArea(846289920)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:37:14.462 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25' '19')
		j1: 	'Jugador 4'
		j2: 	'Jugador 8'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 8'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25' '19')
		j1: 	'Jugador 4'
		j2: 	'Jugador 8'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'19 ¿Qué artista es famoso por sus obras en collage y su est...etc...
		respuestas: 	an OrderedCollection('A) Henri Matisse' 'B) Pablo Picasso' 'C) Geor...etc...
		resultado: 	1
		correcta: 	'B'
		pregunta: 	'¿Qué artista es famoso por sus obras en collage y su estilo único qu...etc...
		nroPregunta: 	'19'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('25' '19')
		j1: 	'Jugador 4'
		j2: 	'Jugador 8'
		band1: 	false
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 4'
		player2: 	'Jugador 8'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	false
		perdedor: 	nil
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(3 1) #(4 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(219444480)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(1060967936)
		label_4: 	a TextMorph(58435840)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(846289920)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846289920)
		secondArg: 	a RubEditingArea(846289920)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846289920)
		secondArg: 	a RubEditingArea(846289920)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(846289920)
		category: 	a KMCategory
		morph: 	a RubEditingArea(846289920)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:38:25.17 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(2 1) #(1 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(2 1) #(1 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(2 1) #(1 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(2 1) #(1 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	1
		listaAdversarios: 	an OrderedCollection(#(2 1) #(1 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	3
		matriz: 	an Array(an Array(a Casilla a Casilla) an Array(a Casilla a Casilla))
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador)
		tamañoMatriz: 	2
		ventana: 	a Morph(416160256)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(51987712)
		label_4: 	a TextMorph(806717184)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(462720512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(462720512)
		secondArg: 	a RubEditingArea(462720512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(462720512)
		secondArg: 	a RubEditingArea(462720512)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(462720512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(462720512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(462720512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(462720512)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:38:25.271 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(2 1) #(1 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(2 1) #(1 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(2 1) #(1 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(2 1) #(1 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	1
		listaAdversarios: 	an OrderedCollection(#(2 1) #(1 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	3
		matriz: 	an Array(an Array(a Casilla a Casilla) an Array(a Casilla a Casilla))
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador)
		tamañoMatriz: 	2
		ventana: 	a Morph(416160256)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(51987712)
		label_4: 	a TextMorph(806717184)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(462720512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(462720512)
		secondArg: 	a RubEditingArea(462720512)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(462720512)
		secondArg: 	a RubEditingArea(462720512)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(462720512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(462720512)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(462720512)
		category: 	a KMCategory
		morph: 	a RubEditingArea(462720512)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:55:28.409 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3) nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	5


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3) nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	5


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	8
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(1056884480)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(621009408)
		label_4: 	a TextMorph(147805440)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(739585024)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(739585024)
		secondArg: 	a RubEditingArea(739585024)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(739585024)
		secondArg: 	a RubEditingArea(739585024)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(739585024)
		category: 	a KMCategory
		morph: 	a RubEditingArea(739585024)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(739585024)
		category: 	a KMCategory
		morph: 	a RubEditingArea(739585024)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 8:55:28.543 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3) nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	5


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3) nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	5


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(3 2) #(2 1) #(2 3) #(1 1) #(1 3))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	8
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(1056884480)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(621009408)
		label_4: 	a TextMorph(147805440)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(739585024)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(739585024)
		secondArg: 	a RubEditingArea(739585024)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(739585024)
		secondArg: 	a RubEditingArea(739585024)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(739585024)
		category: 	a KMCategory
		morph: 	a RubEditingArea(739585024)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(739585024)
		category: 	a KMCategory
		morph: 	a RubEditingArea(739585024)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psTHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:09:50.101 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Qué documento estableció la independencia de las 13 col...etc...
		respuestas: 	an OrderedCollection(' A) La Carta Magna' ' B) La Declaración de In...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué documento estableció la independencia de las 13 colonias americ...etc...
		nroPregunta: 	'15'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 2'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 2'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Qué documento estableció la independencia de las 13 col...etc...
		respuestas: 	an OrderedCollection(' A) La Carta Magna' ' B) La Declaración de In...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué documento estableció la independencia de las 13 colonias americ...etc...
		nroPregunta: 	'15'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 2'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Qué documento estableció la independencia de las 13 col...etc...
		respuestas: 	an OrderedCollection(' A) La Carta Magna' ' B) La Declaración de In...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué documento estableció la independencia de las 13 colonias americ...etc...
		nroPregunta: 	'15'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 2'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 2'
		player2: 	'Jugador 5'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	2
		listaAdversarios: 	an OrderedCollection(#(1 1) #(2 2) #(3 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	8
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(594678528)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(866805248)
		label_4: 	a TextMorph(373391104)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego 
'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(714809344)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(714809344)
		secondArg: 	a RubEditingArea(714809344)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(714809344)
		secondArg: 	a RubEditingArea(714809344)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(714809344)
		category: 	a KMCategory
		morph: 	a RubEditingArea(714809344)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:09:50.25 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Qué documento estableció la independencia de las 13 col...etc...
		respuestas: 	an OrderedCollection(' A) La Carta Magna' ' B) La Declaración de In...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué documento estableció la independencia de las 13 colonias americ...etc...
		nroPregunta: 	'15'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 2'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 2'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Qué documento estableció la independencia de las 13 col...etc...
		respuestas: 	an OrderedCollection(' A) La Carta Magna' ' B) La Declaración de In...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué documento estableció la independencia de las 13 colonias americ...etc...
		nroPregunta: 	'15'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 2'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'15 ¿Qué documento estableció la independencia de las 13 col...etc...
		respuestas: 	an OrderedCollection(' A) La Carta Magna' ' B) La Declaración de In...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Qué documento estableció la independencia de las 13 colonias americ...etc...
		nroPregunta: 	'15'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('15')
		j1: 	'Jugador 2'
		j2: 	'Jugador 5'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 2'
		player2: 	'Jugador 5'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	2
		listaAdversarios: 	an OrderedCollection(#(1 1) #(2 2) #(3 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	8
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(594678528)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(866805248)
		label_4: 	a TextMorph(373391104)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego 
'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 28) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego 
' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego 
'
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego 
'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(714809344)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(714809344)
		secondArg: 	a RubEditingArea(714809344)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(714809344)
		secondArg: 	a RubEditingArea(714809344)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(714809344)
		category: 	a KMCategory
		morph: 	a RubEditingArea(714809344)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:16:30.612 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Cuál fue el primer país en enviar un satélite artificia...etc...
		respuestas: 	an OrderedCollection(' A) Estados Unidos' ' B) Alemania' ' C) Japón...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Cuál fue el primer país en enviar un satélite artificial al espacio...etc...
		nroPregunta: 	'32'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 3'
		j2: 	'Jugador 4'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 3'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Cuál fue el primer país en enviar un satélite artificia...etc...
		respuestas: 	an OrderedCollection(' A) Estados Unidos' ' B) Alemania' ' C) Japón...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Cuál fue el primer país en enviar un satélite artificial al espacio...etc...
		nroPregunta: 	'32'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 3'
		j2: 	'Jugador 4'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Cuál fue el primer país en enviar un satélite artificia...etc...
		respuestas: 	an OrderedCollection(' A) Estados Unidos' ' B) Alemania' ' C) Japón...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Cuál fue el primer país en enviar un satélite artificial al espacio...etc...
		nroPregunta: 	'32'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 3'
		j2: 	'Jugador 4'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 3'
		player2: 	'Jugador 4'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	3
		listaAdversarios: 	an OrderedCollection(#(2 1) #(4 1) #(3 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(736617984)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(95495168)
		label_4: 	a TextMorph(818885888)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(686990848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(686990848)
		secondArg: 	a RubEditingArea(686990848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(686990848)
		secondArg: 	a RubEditingArea(686990848)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(686990848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(686990848)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:16:30.709 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Cuál fue el primer país en enviar un satélite artificia...etc...
		respuestas: 	an OrderedCollection(' A) Estados Unidos' ' B) Alemania' ' C) Japón...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Cuál fue el primer país en enviar un satélite artificial al espacio...etc...
		nroPregunta: 	'32'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 3'
		j2: 	'Jugador 4'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'historia'
		rtaNum: 	nil
		nom: 	'Jugador 3'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Cuál fue el primer país en enviar un satélite artificia...etc...
		respuestas: 	an OrderedCollection(' A) Estados Unidos' ' B) Alemania' ' C) Japón...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Cuál fue el primer país en enviar un satélite artificial al espacio...etc...
		nroPregunta: 	'32'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 3'
		j2: 	'Jugador 4'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'historia'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'32 ¿Cuál fue el primer país en enviar un satélite artificia...etc...
		respuestas: 	an OrderedCollection(' A) Estados Unidos' ' B) Alemania' ' C) Japón...etc...
		resultado: 	nil
		correcta: 	'D'
		pregunta: 	'¿Cuál fue el primer país en enviar un satélite artificial al espacio...etc...
		nroPregunta: 	'32'
		frase: 	#('01 ¿Quién fue el primer presidente de los Estados Unidos? A) Abraham ...etc...
		listaPreguntas: 	an OrderedCollection('32')
		j1: 	'Jugador 3'
		j2: 	'Jugador 4'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 3'
		player2: 	'Jugador 4'
		player2cat: 	'historia'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	nil
		categoria: 	'historia'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	3
		listaAdversarios: 	an OrderedCollection(#(2 1) #(4 1) #(3 2))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	64
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(736617984)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(95495168)
		label_4: 	a TextMorph(818885888)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(686990848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(686990848)
		secondArg: 	a RubEditingArea(686990848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(686990848)
		secondArg: 	a RubEditingArea(686990848)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(686990848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(686990848)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Pharo cannot write to the changes file named C:\Users\tiago\Documents\Pharo\images\PP-C2-F-BBGQS\PP-C2-F-BBGQS.changes.

Please check that you have write permission for this file.

You won't be able to save this image correctly until you fix this.
24 November 2024 9:16:52.64 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

StartupUIManager>>inform:
	Receiver: a StartupUIManager
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to the changes file named C:\Users\tiago\Documents\Ph...etc...
		tmp1: 	nil
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	nil


PharoFilesOpener(Object)>>inform:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to the changes file named C:\Users\tiago\Documents\Ph...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>inform:withRef:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to &fileRef.

Please check that you have write permis...etc...
		arg2: 	'the changes file named C:\Users\tiago\Documents\Pharo\images\PP-C2-F-BBG...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>inform:withChangesRef:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to &fileRef.

Please check that you have write permis...etc...
		arg2: 	'C:\Users\tiago\Documents\Pharo\images\PP-C2-F-BBGQS\PP-C2-F-BBGQS.change...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>informProblemInChanges:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to &fileRef.

Please check that you have write permis...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>changesFileOrNilReadOnly:silent:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	false
		arg2: 	false
		tmp1: 	SourceFile(C:\Users\tiago\Documents\Pharo\images\PP-C2-F-BBGQS\PP-C2-F-BB...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>changesFileOrNilReadOnly:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	false
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>changesFileOrNil
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


SourceFileArray>>ensureOpen
	Receiver: a SourceFileArray
	Arguments and temporary variables: 
		tmp1: 	SourceFile(C:\Users\tiago\Documents\Pharo\images\PP-C2-F-BBGQS\Pharo9.0-6...etc...
		tmp2: 	nil
	Receiver's instance variables: 
		files: 	#(nil nil)
		readOnlyQueue: 	SharedQueue with 0 items
		flushChanges: 	true


SmalltalkImage>>openSourceFiles
	Receiver: Smalltalk
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		vm: 	a VirtualMachine


SourceFileArray class>>startUp:
	Receiver: SourceFileArray
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#changeRecordsFor:->SourceFileArray>>#changeReco...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SourceFileArray
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Sources-Sources'


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(SourceFileArray)
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		registeredClassName: 	#SourceFileArray


[ :arg2 | arg2 startup: arg1 ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	true
		arg2: 	a ClassSessionHandler(SourceFileArray)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ])
		id: 	nil
		creationTime: 	2024-11-24T21:16:52.481-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


[ arg2 value: arg3 ] in [ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(Sessio...etc...
		arg2: 	a ClassSessionHandler(SourceFileArray)
		arg3: 	[ :arg2 | arg2 startup: arg1 ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ])
		id: 	nil
		creationTime: 	2024-11-24T21:16:52.481-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ arg2 value: arg3 ]
	Arguments and temporary variables: 
		arg1: 	Exception
		arg2: 	[ :arg4 | self errorHandler handleError: arg4 ]
	Receiver's instance variables: 
		outerContext: 	[ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4...etc...
		startpc: 	a CompiledBlock: [ arg2 value: arg3 ]
		numArgs: 	0
		receiver: 	a WorkingSession


[ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(Sessio...etc...
		arg2: 	[ :arg2 | arg2 startup: arg1 ]
		arg3: 	a ClassSessionHandler(SourceFileArray)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ])
		id: 	nil
		creationTime: 	2024-11-24T21:16:52.481-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(SessionAccessModeResolv...etc...
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(SessionAccessModeResolv...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(Sessio...etc...
		arg2: 	[ :arg2 | arg2 startup: arg1 ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ])
		id: 	nil
		creationTime: 	2024-11-24T21:16:52.481-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ])
		id: 	nil
		creationTime: 	2024-11-24T21:16:52.481-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ])
		id: 	nil
		creationTime: 	2024-11-24T21:16:52.481-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


SessionManager>>launchSnapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		arg1: 	true
		arg2: 	true
		tmp1: 	true
		tmp2: 	true
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
	tmp1 signal ] in SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ 
			  self value.
			  Processor terminateActive ] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
	tmp1 signal ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	SessionManager>>snapshot:andQuit:
		startpc: 	a CompiledBlock: [ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
...etc...
		numArgs: 	0
		receiver: 	a SessionManager



--- The full stack ---
StartupUIManager>>inform:
PharoFilesOpener(Object)>>inform:
PharoFilesOpener>>inform:withRef:
PharoFilesOpener>>inform:withChangesRef:
PharoFilesOpener>>informProblemInChanges:
PharoFilesOpener>>changesFileOrNilReadOnly:silent:
PharoFilesOpener>>changesFileOrNilReadOnly:
PharoFilesOpener>>changesFileOrNil
SourceFileArray>>ensureOpen
SmalltalkImage>>openSourceFiles
SourceFileArray class>>startUp:
ClassSessionHandler>>startup:
[ :arg2 | arg2 startup: arg1 ] in WorkingSession>>runStartup:
[ arg2 value: arg3 ] in [ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
FullBlockClosure(BlockClosure)>>on:do:
[ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>launchSnapshot:andQuit:
[ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
	tmp1 signal ] in SessionManager>>snapshot:andQuit:
[ 
			  self value.
			  Processor terminateActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 9:24:13.585 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 0.9002932551319648 g: 0.30009775171065495 b: 0.30009...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 5'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	2
		coordenadasY: 	2
		vecinos: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		categoria: 	'ciencia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		i: 	1
		casilla: 	a Casilla
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(734603776)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(604053248)
		label_4: 	a TextMorph(94262016)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(734603776)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(604053248)
		label_4: 	a TextMorph(94262016)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(126332160)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(126332160)
		secondArg: 	a RubEditingArea(126332160)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(126332160)
		secondArg: 	a RubEditingArea(126332160)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(126332160)
		category: 	a KMCategory
		morph: 	a RubEditingArea(126332160)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(126332160)
		category: 	a KMCategory
		morph: 	a RubEditingArea(126332160)



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 9:24:13.682 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 0.9002932551319648 g: 0.30009775171065495 b: 0.30009...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 5'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	2
		coordenadasY: 	2
		vecinos: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		categoria: 	'ciencia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		i: 	1
		casilla: 	a Casilla
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(734603776)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(604053248)
		label_4: 	a TextMorph(94262016)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(2 2) #(1 1) #(1 3))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(734603776)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(604053248)
		label_4: 	a TextMorph(94262016)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(126332160)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(126332160)
		secondArg: 	a RubEditingArea(126332160)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(126332160)
		secondArg: 	a RubEditingArea(126332160)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(126332160)
		category: 	a KMCategory
		morph: 	a RubEditingArea(126332160)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	11
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(126332160)
		category: 	a KMCategory
		morph: 	a RubEditingArea(126332160)



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 9:25:01.578 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 0.9002932551319648 g: 0.30009775171065495 b: 0.30009...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 7'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	1
		coordenadasY: 	3
		vecinos: 	an OrderedCollection(#(2 3) #(1 2))
		categoria: 	'geografia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(1 3) #(3 3) #(2 2))
		i: 	1
		casilla: 	a Casilla
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(709068800)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(932827648)
		label_4: 	a TextMorph(331790080)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	8
		listaAdversarios: 	an OrderedCollection(#(1 3) #(3 3) #(2 2))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(709068800)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(932827648)
		label_4: 	a TextMorph(331790080)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(36.0@33.0) mouseUp 978379 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(36.0@33.0) mouseUp 978379 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@33.0) mouseUp 978379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(36.0@33.0) mouseUp 978379 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	978379
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(36.0@33.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(36.0@33.0) mouseUp 978379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(651@315) mouseUp 978379 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
		evt: 	[(651@315) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	975304
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(535796224)))
		lastAlarmTime: 	979416
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	975304
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(535796224)))
		lastAlarmTime: 	979416
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 9:25:01.733 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 0.9002932551319648 g: 0.30009775171065495 b: 0.30009...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 7'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	1
		coordenadasY: 	3
		vecinos: 	an OrderedCollection(#(2 3) #(1 2))
		categoria: 	'geografia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(1 3) #(3 3) #(2 2))
		i: 	1
		casilla: 	a Casilla
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(709068800)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(932827648)
		label_4: 	a TextMorph(331790080)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	8
		listaAdversarios: 	an OrderedCollection(#(1 3) #(3 3) #(2 2))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(709068800)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(932827648)
		label_4: 	a TextMorph(331790080)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(36.0@33.0) mouseUp 978379 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(36.0@33.0) mouseUp 978379 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@33.0) mouseUp 978379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(36.0@33.0) mouseUp 978379 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	978379
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(36.0@33.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(36.0@33.0) mouseUp 978379 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(651@315) mouseUp 978379 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(36.0@33.0) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
		evt: 	[(651@315) mouseUp 978379 nil]
	Receiver's instance variables: 
		bounds: 	(992@605.0) corner: (1008@621.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(992@605) mouseOver 979114 nil]
		targetOffset: 	(36.0@28.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(651@315) mouseUp 978379 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 10 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	975304
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(535796224)))
		lastAlarmTime: 	979416
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	975304
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(535796224)))
		lastAlarmTime: 	979416
		activeHand: 	a HandMorph(388493824)
		currentCu<<error during printing>>

WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 9:25:28.006 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 0.9002932551319648 g: 0.30009775171065495 b: 0.30009...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 3'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	1
		coordenadasY: 	2
		vecinos: 	an OrderedCollection(#(2 2) #(1 1))
		categoria: 	'historia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(1 2) #(2 1))
		i: 	1
		casilla: 	a Casilla
	Receiver's instance variables: 
		cantPlayers: 	4
		matriz: 	an Array(an Array(a Casilla a Casilla) an Array(a Casilla a Casilla))
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador)
		tamañoMatriz: 	2
		ventana: 	a Morph(1024419584)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(1043811072)
		label_4: 	a TextMorph(540648960)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(1 2) #(2 1))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	4
		matriz: 	an Array(an Array(a Casilla a Casilla) an Array(a Casilla a Casilla))
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador)
		tamañoMatriz: 	2
		ventana: 	a Morph(1024419584)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(1043811072)
		label_4: 	a TextMorph(540648960)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(33.0@26.0) mouseUp 1004565 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(33.0@26.0) mouseUp 1004565 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(33.0@26.0) mouseUp 1004565 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	1004565
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(33.0@26.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		evt: 	[(648@308) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	993823
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(271904000)))
		lastAlarmTime: 	1005858
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	993823
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(271904000)))
		lastAlarmTime: 	1005858
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
Casilla(Object)>>doesNotUnderstand: #color:
Tablero>>coloresAdversarios:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Casilla did not understand #color:
24 November 2024 9:25:28.119 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Casilla(Object)>>doesNotUnderstand: #color:
	Receiver: a Casilla
	Arguments and temporary variables: 
		aMessage: 	color: (Color r: 0.9002932551319648 g: 0.30009775171065495 b: 0.30009...etc...
		exception: 	Instance of Casilla did not understand #color:
		resumeValue: 	nil
	Receiver's instance variables: 
		dueño: 	'Jugador 3'
		color: 	Color blue
		tema: 	nil
		coordenadasX: 	1
		coordenadasY: 	2
		vecinos: 	an OrderedCollection(#(2 2) #(1 1))
		categoria: 	'historia'
		pregunta: 	nil
		boton: 	nil


Tablero>>coloresAdversarios:
	Receiver: a Tablero
	Arguments and temporary variables: 
		listaAdversarios: 	an OrderedCollection(#(1 2) #(2 1))
		i: 	1
		casilla: 	a Casilla
	Receiver's instance variables: 
		cantPlayers: 	4
		matriz: 	an Array(an Array(a Casilla a Casilla) an Array(a Casilla a Casilla))
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador)
		tamañoMatriz: 	2
		ventana: 	a Morph(1024419584)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(1043811072)
		label_4: 	a TextMorph(540648960)


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	4
		listaAdversarios: 	an OrderedCollection(#(1 2) #(2 1))
		respuesta: 	nil
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	4
		matriz: 	an Array(an Array(a Casilla a Casilla) an Array(a Casilla a Casilla))
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador)
		tamañoMatriz: 	2
		ventana: 	a Morph(1024419584)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(1043811072)
		label_4: 	a TextMorph(540648960)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(33.0@26.0) mouseUp 1004565 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(33.0@26.0) mouseUp 1004565 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(33.0@26.0) mouseUp 1004565 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	1004565
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(33.0@26.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(33.0@26.0) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
		evt: 	[(648@308) mouseUp 1004565 nil]
	Receiver's instance variables: 
		bounds: 	(812@364.0) corner: (828@380.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(804@355) mouseOver 1005150 nil]
		targetOffset: 	(33.0@21.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(648@308) mouseUp 1004565 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 1 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	993823
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(271904000)))
		lastAlarmTime: 	1005858
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a Morph(...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	993823
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(271904000)))
		lastAlarmTime: 	1005858
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:25:53.758 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(1 2) #(3 2) #(2 1) #(2 3) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(1 2) #(3 2) #(2 1) #(2 3) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(608485376)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(496851456)
		label_4: 	a TextMorph(94138112)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(16.0@17.0) mouseUp 1027900 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(16.0@17.0) mouseUp 1027900 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(16.0@17.0) mouseUp 1027900 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	1027900
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(16.0@17.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		evt: 	[(631@299) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1031826
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1031826
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:25:53.871 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(1 2) #(3 2) #(2 1) #(2 3) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(1 2) #(3 2) #(2 1) #(2 3) nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	4


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(1 2) #(3 2) #(2 1) #(2 3))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	9
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla) an Array(a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	3
		ventana: 	a Morph(608485376)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(496851456)
		label_4: 	a TextMorph(94138112)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(16.0@17.0) mouseUp 1027900 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(16.0@17.0) mouseUp 1027900 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(16.0@17.0) mouseUp 1027900 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	1027900
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(16.0@17.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(16.0@17.0) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
		evt: 	[(631@299) mouseUp 1027900 nil]
	Receiver's instance variables: 
		bounds: 	(1090@467.0) corner: (1106@483.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(1090@467.0) corner: (1106@483.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1090@467) mouseOver 1031815 nil]
		targetOffset: 	(28.0@14.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(631@299) mouseUp 1027900 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1031826
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1031826
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:26:05.552 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(4 1) #(5 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(4 1) #(5 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(4 1) #(5 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(4 1) #(5 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(4 1) #(5 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	25
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla) an...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	5
		ventana: 	a Morph(287861248)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(878960384)
		label_4: 	a TextMorph(147428096)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(22.0@5.0) mouseUp 1040286 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(22.0@5.0) mouseUp 1040286 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@5.0) mouseUp 1040286 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	1040286
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@5.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		evt: 	[(637@287) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 15 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1043617
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1043617
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:26:05.666 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(4 1) #(5 2))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(4 1) #(5 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(4 1) #(5 2))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(4 1) #(5 2) nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	2


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	5
		listaAdversarios: 	an OrderedCollection(#(4 1) #(5 2))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	25
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla) an...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	5
		ventana: 	a Morph(287861248)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(878960384)
		label_4: 	a TextMorph(147428096)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(728723968))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(728723968)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		event: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(22.0@5.0) mouseUp 1040286 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
		m: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(1031844096) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		evt: 	[(22.0@5.0) mouseUp 1040286 nil]
		all: 	an Array(a SpToolbarButtonMorph(728723968) a SpToolbarButtonMorph(10318440...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@5.0) mouseUp 1040286 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(728723968)
	Receiver's instance variables: 
		timeStamp: 	1040286
		source: 	a HandMorph(388493824)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@5.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(728723968)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(566368000)
		submorphs: 	an Array(an AlignmentMorph(863085824))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (271712768) [balloonText]  [other:  (kmDispatcher -...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	nil
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(52783104)'Do it'
		iconMorph: 	an ImageMorph(216764672)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(388493824)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(603310592) [world]
		transformedEvent: 	[(22.0@5.0) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		focusHolder: 	a SpToolbarButtonMorph(728723968)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(388493824)
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
		evt: 	[(637@287) mouseUp 1040286 nil]
	Receiver's instance variables: 
		bounds: 	(788@252.0) corner: (804@268.0)
		owner: 	a WorldMorph(603310592) [world]
		submorphs: 	#()
		fullBounds: 	(788@252.0) corner: (804@268.0)
		color: 	Color blue
		extension: 	a MorphExtension (998404608)
		mouseFocus: 	nil
		keyboardFocus: 	a SpToolbarButtonMorph(728723968)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(788@252) mouseOver CTRL 1043609 nil]
		targetOffset: 	(202.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		lastKeyScanCode: 	nil
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(637@287) mouseUp 1040286 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(603310592) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
		queue: 	WaitfreeQueue with 30 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1043617
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(603310592) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(388493824))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1022518
		lastStepMessage: 	nil
		alarms: 	a Heap()
		lastAlarmTime: 	1043617
		activeHand: 	a HandMorph(388493824)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1920@1009)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(603310592) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1920@1009)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(261299968) a TaskbarMorph(65834496) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (841104384) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->true #CursorOwnerWorld->a WorldMorph(6...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in STHERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:26:26.16 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(3 3) #(4 2) #(4 4))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(3 3) #(4 2) #(4 4) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(3 3) #(4 2) #(4 4))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(3 3) #(4 2) #(4 4) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	12
		listaAdversarios: 	an OrderedCollection(#(3 3) #(4 2) #(4 4))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(1013835008)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(317856768)
		label_4: 	a TextMorph(353394176)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(974170368)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(974170368)
		secondArg: 	a RubEditingArea(974170368)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(974170368)
		secondArg: 	a RubEditingArea(974170368)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(974170368)
		category: 	a KMCategory
		morph: 	a RubEditingArea(974170368)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(974170368)
		category: 	a KMCategory
		morph: 	a RubEditingArea(974170368)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 9:26:26.265 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

OrderedCollection(Object)>>errorSubscriptBounds:
	Receiver: an OrderedCollection(#(3 3) #(4 2) #(4 4))
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
		array: 	#(#(3 3) #(4 2) #(4 4) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


OrderedCollection>>at:
	Receiver: an OrderedCollection(#(3 3) #(4 2) #(4 4))
	Arguments and temporary variables: 
		anInteger: 	0
		index: 	nil
	Receiver's instance variables: 
		array: 	#(#(3 3) #(4 2) #(4 4) nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	12
		listaAdversarios: 	an OrderedCollection(#(3 3) #(4 2) #(4 4))
		respuesta: 	0
		duelo: 	a Duelos
		contadorDuelos: 	0
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	16
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla) an Array(a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	4
		ventana: 	a Morph(1013835008)
		atacante: 	a Jugador
		defensor: 	nil
		lista: 	nil
		ventana_4: 	an ImageMorph(317856768)
		label_4: 	a TextMorph(353394176)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(974170368)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(974170368)
		secondArg: 	a RubEditingArea(974170368)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(974170368)
		secondArg: 	a RubEditingArea(974170368)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(974170368)
		category: 	a KMCategory
		morph: 	a RubEditingArea(974170368)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(974170368)
		category: 	a KMCategory
		morph: 	a RubEditingArea(974170368)



--- The full stack ---
OrderedCollection(Object)>>errorSubscriptBounds:
OrderedCollection>>at:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 10:15:41.95 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'09 ¿Quién pintó la famosa obra "Las meninas"?A) Francisco d...etc...
		respuestas: 	an OrderedCollection('A) Francisco de Goya' 'B) Diego Velázquez' 'C...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Quién pintó la famosa obra "Las meninas"'
		nroPregunta: 	'09'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('09')
		j1: 	'Jugador 8'
		j2: 	'Jugador 15'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 8'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'09 ¿Quién pintó la famosa obra "Las meninas"?A) Francisco d...etc...
		respuestas: 	an OrderedCollection('A) Francisco de Goya' 'B) Diego Velázquez' 'C...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Quién pintó la famosa obra "Las meninas"'
		nroPregunta: 	'09'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('09')
		j1: 	'Jugador 8'
		j2: 	'Jugador 15'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'09 ¿Quién pintó la famosa obra "Las meninas"?A) Francisco d...etc...
		respuestas: 	an OrderedCollection('A) Francisco de Goya' 'B) Diego Velázquez' 'C...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Quién pintó la famosa obra "Las meninas"'
		nroPregunta: 	'09'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('09')
		j1: 	'Jugador 8'
		j2: 	'Jugador 15'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 8'
		player2: 	'Jugador 15'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	8
		listaAdversarios: 	an OrderedCollection(#(7 1) #(7 2) #(8 3))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(269281792)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(1072914176)
		label_4: 	a TextMorph(48632576)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(846548736)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846548736)
		secondArg: 	a RubEditingArea(846548736)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846548736)
		secondArg: 	a RubEditingArea(846548736)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(846548736)
		category: 	a KMCategory
		morph: 	a RubEditingArea(846548736)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
24 November 2024 10:15:42.163 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 28d08f23-7eb4-0d00-a74a-9ef702f9ba6c Mar 30 2023
v9.0.22 - Commit: 421845e1 - Date: 2023-03-30 09:49:26 +0200

Image: Pharo9.0.0 [Build information: Pharo-9.0.0+build.1580.sha.e1bb0fb7b6c4aaadd5106d19b58633c94dff1b69 (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Array(Object)>>at:
	Receiver: #('A' 'B' 'C' 'D' 0)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#('A' 'B' 'C' 'D' 0)

Pregunta>>opcionNumeroALetra:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		a: 	0
		listaOpciones: 	#('A' 'B' 'C' 'D' 0)
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'09 ¿Quién pintó la famosa obra "Las meninas"?A) Francisco d...etc...
		respuestas: 	an OrderedCollection('A) Francisco de Goya' 'B) Diego Velázquez' 'C...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Quién pintó la famosa obra "Las meninas"'
		nroPregunta: 	'09'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('09')
		j1: 	'Jugador 8'
		j2: 	'Jugador 15'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>mostrarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		cat: 	'arte'
		rtaNum: 	nil
		nom: 	'Jugador 8'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'09 ¿Quién pintó la famosa obra "Las meninas"?A) Francisco d...etc...
		respuestas: 	an OrderedCollection('A) Francisco de Goya' 'B) Diego Velázquez' 'C...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Quién pintó la famosa obra "Las meninas"'
		nroPregunta: 	'09'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('09')
		j1: 	'Jugador 8'
		j2: 	'Jugador 15'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Pregunta>>llamarPregunta:
	Receiver: a Pregunta
	Arguments and temporary variables: 
		categoria: 	'arte'
	Receiver's instance variables: 
		opcion: 	nil
		preguntaAleatoria: 	'09 ¿Quién pintó la famosa obra "Las meninas"?A) Francisco d...etc...
		respuestas: 	an OrderedCollection('A) Francisco de Goya' 'B) Diego Velázquez' 'C...etc...
		resultado: 	nil
		correcta: 	'B'
		pregunta: 	'¿Quién pintó la famosa obra "Las meninas"'
		nroPregunta: 	'09'
		frase: 	#('01 ¿Quién pintó "La Gioconda"?A) Miguel Ángel%B) Leonardo da Vinci%C)...etc...
		listaPreguntas: 	an OrderedCollection('09')
		j1: 	'Jugador 8'
		j2: 	'Jugador 15'
		band1: 	true
		rtaPlayer: 	0
		t: 	false


Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
	Receiver: a Duelos
	Arguments and temporary variables: 
		player1: 	'Jugador 8'
		player2: 	'Jugador 15'
		player2cat: 	'arte'
		arg1: 	false
		pregunta: 	a Pregunta
	Receiver's instance variables: 
		timer: 	a Timer
		bandJugador1: 	true
		perdedor: 	1
		categoria: 	'arte'


Tablero>>iniciarJuego
	Receiver: a Tablero
	Arguments and temporary variables: 
		nroAtacante: 	8
		listaAdversarios: 	an OrderedCollection(#(7 1) #(7 2) #(8 3))
		respuesta: 	2
		duelo: 	a Duelos
		contadorDuelos: 	1
		ventanaVictoria: 	nil
		labelVictoria: 	nil
	Receiver's instance variables: 
		cantPlayers: 	63
		matriz: 	an Array(an Array(a Casilla a Casilla a Casilla a Casilla a Casilla a C...etc...
		listaJugadores: 	an Array(a Jugador a Jugador a Jugador a Jugador a Jugador a Ju...etc...
		tamañoMatriz: 	8
		ventana: 	a Morph(269281792)
		atacante: 	a Jugador
		defensor: 	a Casilla
		lista: 	nil
		ventana_4: 	an ImageMorph(1072914176)
		label_4: 	a TextMorph(48632576)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Tablero new iniciarJuego
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'(Tablero new) iniciarJuego '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 27) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '(Tablero new) iniciarJuego ' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aString: 	'(Tablero new) iniciarJuego '
		aBlock: 	[ :result | ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | ]
		selection: 	'(Tablero new) iniciarJuego '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		b<<error during printing>>

SpCodeDoItCommand>>execute
	Receiver: a SpCodeDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Do it'
		basicDescription: 	'Evaluate selection.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeDoItCommand
		iconProvider: 	nil
		iconName: 	#smallDoIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Do it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(846548736)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846548736)
		secondArg: 	a RubEditingArea(846548736)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(846548736)
		secondArg: 	a RubEditingArea(846548736)
		thirdArg: 	[keyDown '<Ctrl-d>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(846548736)
		category: 	a KMCategory
		morph: 	a RubEditingArea(846548736)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-d>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:
Pregunta>>opcionNumeroALetra:
Pregunta>>mostrarPregunta:
Pregunta>>llamarPregunta:
Duelos>>iniciarDueloEntre:y:categoria:dueloExtra:
Tablero>>iniciarJuego
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ self extraWorldList ].
		extraWorldsToDraw do: [:world |
			world doOneCycle.
		].

		(self currentWorld isNotNil and: [(extraWorldsToDraw includes: self currentWorld) not]) ifTrue: [
			self currentWorld doOneCycle.
		]
	] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			Processor terminateActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

